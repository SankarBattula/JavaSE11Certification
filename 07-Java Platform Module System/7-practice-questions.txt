
1. What is the name of a file that declares a module?
    A. mod.java
    B. mod-data.java
    C. mod-info.java
    D. module.java
    E. module-data.java
    F. module-info.java

    Explanation :
    F. The module-info.java file is used to declare a module. 
    You must memorize the name of this file.

2. Suppose you have a module that contains a class with a call to
    exports(ChocolateLab.class). Which part of the module service contains this class?
    
    A. Consumer
    B. Service locator
    C. Service provider
    D. Service provider interface
    E. None of the above

    Explanation :
    E. The service locator contains a load() method, not an exports() method, making option E the answer.

3. Which are considered part of a service? (Choose two.)
    A. Consumer
    B. Service locator
    C. Service provider
    D. Service provider interface

    Explanation :
    B,D. A service is comprised of the interface, any classes the interface references, and a way to look up implementations of the interface. 
    Option B covers the lookup, and option D covers the interface itself.

4. Given the following diagram, how many of the following are named modules?

        classpath       |     module path
    ___________________ | ____________________
    | dog.fluffy.jar  | | |  dog.hair.jar    |
    |                 | | |                  |
    |     dog.fluffy  | | |      dog.hair    |
    |_________________| | |__________________|
     __________________ | ____________________
    | dog.husky.jar   | | |  dog.bark.jar    |
    |                 | | |                  |
    |     dog.husky   | | |      dog.bark    |
    |    module-info  | | |     module-info  |
    |_________________| | |__________________|

    A. 0
    B. 1
    C. 2
    D. 3
    E. 4

    Explanation :
    B. A named module must be on the module path and contain a module-info file. 
    Only dog.bark meets this criterion, making option B the answer.

5. Given the diagram from the previous question, which is an automatic module?
    A. dog.bark
    B. dog.fluffy
    C. dog.hair
    D. dog.husky
    E. None of the above

    Explanation :
    C. An automatic module must be on the module path but does not contain a module-info file. 
    Option C is correct because dog.hair matches this description.

6. Given the diagram from question 4, which is a default module?
    A. dog.bark
    B. dog.fluffy
    C. dog.hair
    D. dog.husky
    E. None of the above

    Explanation :
    E. You need to know about three types of modules for the exam: automatic, named, and unnamed. 
    There is no such thing as a default module. The question was trying to trick you, and option E is correct.

7. Given the diagram from question 4, how many are unnamed modules?
    A. 0
    B. 1
    C. 2
    D. 3
    E. 4

    Explanation :
    C. An unnamed module must be on the classpath. It is rare to have a module-info file in an unnamed module, but it is allowed. 
    Therefore, both dog.fluffy and dog.husky meet this criterion, making option C correct.

8. Which of the following statements are true? (Choose two.)

    A. It is a good practice to add the --add-exports option to your java command.
    B. It is permitted, but not recommended, to add the --add-exports option to your java command.
    C. There is no --add-exports option on the java command.
    D. It is a good practice to add the --add-requires option to your java command.
    E. It is permitted, but not recommended, to add the --add-requires option to your java command.
    F. There is no --add-requires option on the java command.

    Explanation :
    B,F. It is recommended to specify all exports directives in the module-info file. 
    While it is legal to use the --add-exports option, it is not recommended, making option B correct. 
    You do not need to know how to use it for the exam, just that it is not a good idea. 
    There is no equivalent option for requires, making option F correct.

9. How many of the following are legal module-info.java files?
    module com.koala {
        exports cute;
    }
    module com-koala {
        exports cute;
    }
    public module com.koala {
        exports cute;
    }
    public module com-koala {
        exports cute;
    }

    A. None
    B. One
    C. Two
    D. Three
    E. Four

    Explanation :
    B. Since Java does not allow dashes in identifier names, the second and fourth declarations are invalid. 
    Additionally, access modifiers are not permitted in module declarations, making the third and fourth declarations invalid. 
    The only one that is legal is the first declaration, so option B is correct.

10. Which two would be best to combine into a single module?
    A. Consumer and service locator
    B. Consumer and service provider
    C. Consumer and service provider interface
    D. Service locator and service provider interface
    E. Service locator and service provider
    F. Service provider and service provider interface

    Explanation :
    D. The consumer is generally separate ruling out options A, B, and C. 
    The service provider is decoupled from the service provider interface ruling out option F. 
    It is most logical to combine the service locator and service provider interface because neither has a direct reference to the service provider. 
    Therefore, option D is correct.

11. What command could you run to print output like the following?
    java.base@11.0.2
    java.compiler@11.0.2
    java.datatransfer@11.0.2
    java.desktop@11.0.2
    ...
    A. java --all-modules
    B. java --describe-modules
    C. java --list-modules
    D. java --output-modules
    E. java --show-modules
    F. None of the above

    Explanation :
    C. The java command has an option to list all the modules that come with the JDK. 
    Option C is correct since that option is called --list-modules. 
    The other options are not supported by the java command. 
    Options B and E are similar to options that exist: --describe-module and --show-module-resolution. 
    But neither gives a list of all the modules that come with the JDK.

12. Suppose we have an automatic module on the module path named dog-arthur2.jar and
    no Automatic-Module-Name specified? What module name should named modules use to
    reference it?

    A. dog-arthur
    B. dog-arthur2
    C. dog.arthur
    D. dog.arthur2
    E. None of the above

    Explanation :
    C. The rules for determining the name include removing the extension, removing numbers, and changing special characters to periods (.). 
    This leaves us with dog.arthur, which is option C. 

13. Given the dependencies in the diagram, which boxes represent the service provider interface
    and service provider, respectively?
    W --------> X
                ^
                |
    Y <-------- Z

    A. W and X
    B. W and Z
    C. X and Y
    D. X and Z
    E. Y and Z
    F. None of the above

    Explanation :
    C. All parts of a modules service must point to the service provider interface. 
    This tells us the service provider interface must be X, ruling out options A, B, and E. 
    Now, we have to decide if Y or Z are the service provider interface. 
    We can tell because nothing has a direct dependency on the service provider. 
    Since this makes the service provider Y, the answer is option C.

14. Using the diagram in the previous question, which boxes represent the consumer and service
    locator, respectively?
    A. W and X
    B. W and Z
    C. X and Y
    D. X and Z
    E. Y and Z
    F. None of the above

    Explanation :
    B. The consumer depends on the service provider interface and service locator, but not the service provider. 
    Only W has two arrows starting from it so, it must be the consumer. This rules out options C, D, and E. 
    The service locator references the service provider interface directly and the service provider indirectly, 
    making the service locator Z and option B the answer.

15. What is the minimum number of JAR files you need for a cyclic dependency?
    A. 0
    B. 1
    C. 2
    D. 3
    E. 4

    Explanation :
    C. A cyclic dependency is when two things directly or indirectly depend on each other. 
    If chicken.jar depends on egg.jar, and egg.jar depends on chicken.jar, we have a cyclic dependency. 
    Since only two JAR files are needed to create this situation, option C is the answer.

16. Fill in the blank with code to look up and call a service.
    String cheese = ServiceLoader.load(Mouse.class)
    .map(______________)
    .map(Mouse::favoriteFood)
    .findFirst()
    .orElse("");

    A. Mouse.get()
    B. Mouse::get
    C. Provider.get()
    D. Provider::get
    E. None of the above

    Explanation :
    E. The ServiceLoader class has a load() method that returns a Collection of Provider, not a stream. 
    Since the call to stream() is missing, option E is the answer. If the call to stream() were added, option D would be the answer.

17. Suppose we want to have two modules: com.ny and com.sf. Which is true about the
    placement of the module-info.java file(s)?
    module com.ny                   module com.sf
        package com.ny.city             package com.sf.city
                V                               X
                W                               Y
                Z

    A. One module-info.java file is required in position Z.
    B. Two module-info.java files are required, in positions V and X.
    C. Two module-info.java files are required, in positions W and Y.
    D. Three module-info.java files are required, in positions V, X, and Z.
    E. Three module-info.java files are required, in positions W, Y, and Z.
    F. None of the above.

    Explanation :
    C. Each module is required to have its own module-info.java file in the root directory of the module. 
    For module com.ny, that is location W, and for module com.sf, that is location Y. 
    Therefore, option B is correct

18. Consider the modules in the previous diagram. Suppose we want the code in module com.sf
    to depend on code in module com.ny. Which of the following directives goes into module
    com.sf’s module-info file to configure that behavior?

    A. export com.ny;
    B. exports com.ny;
    C. require com.ny;
    D. require com.ny.city;
    E. requires com.ny;
    F. requires com.ny.city;

    Explanation :
    E. Options A, C, and D are incorrect because export and require are not keywords in modules. 
    Option B is incorrect because that directive goes in the com.ny module, not the com.sf one. 
    Option E is correct rather than option F because the requires directive references a module name rather than a package.

19. Consider the modules diagram in question 17. Suppose we want the code in module com.sf
    to depend on code in module com.ny. Which of the following directives goes into module
    com.ny’s module-info file to configure that behavior?

    A. export com.ny;
    B. export com.ny.city;
    C. exports com.ny;
    D. exports com.ny.city;
    E. requires com.ny;
    F. requires com.ny.city;

    Explanation :
    D. Options A and B are incorrect because export is not a keyword in modules. Option E belongs in the com.sf module, not the com.ny one. 
    Option F is incorrect because the requires directive references a module name rather than a package. 
    Finally, option D is the answer rather than option C because the exports directive references a package name rather than a module.

20. Suppose the consumer, service locator, service provider, and service provider interface are
    each in separate modules. Which of the following best describes the following moduleinfo
    file?

    module nature.tree {
        provides nature.sapling.Tree with nature.tree.Maple
    }

    A. Consumer
    B. Service locator
    C. Service provider
    D. Service provider interface
    E. None of the above

    Explanation :
    E. The Maple class is intended to be an implementation of the Tree interface. However, this interface needs to be accessible. 
    This module is missing a requires nature.sapling; statement, making option E the correct answer.

21. Which options are commonly used when compiling a module?

    A. -d and -m
    B. -d and -p
    C. -m and -p
    D. -d, -m, and -p
    E. None of the above

    Explanation :
    B. The –d option specifies the directory. 
    The –p option specifies the module path. 
    The –m option is not available on the javac command.

22. Which of the following are modules supplied by the JDK? (Choose three.)

    A. java.base
    B. java.basic
    C. java.desktop
    D. java.sdk
    E. java.sql
    F. java.swing

    Explanation :
    A,C,E. The java.base module is automatically available to any module without specifying it, making option A correct. 
    Options C and E are also correct because java.desktop and java.sql are modules supplied with the JDK. 
    You do need to be able to identify built-in modules for the exam.

23. Which best describes a top-down migration? (Choose two.)

    A. The first step is to move all the modules to the module path.
    B. The first step is to move a single module to the module path.
    C. Most steps consist of changing an automatic module to a named module.
    D. Most steps consist of changing an automatic module to a unnamed module.
    E. Most steps consist of changing an unnamed module to an automatic module.
    F. Most steps consist of changing an unnamed module to a named module

    Explanation :
    A,C. Option A is correct because a top-down migration starts by moving all the modules to the module path as automatic modules. 
    Then, the migration changes each module from an automatic module to a named module, making option C the other correct answer.

24. Suppose the consumer, service locator, service provider, and service provider interface are
    each in separate modules. Which of the following best describes the following
    module-info file?
    module nature.tree {
        requires nature.sapling;
        requires nature.bush;
    }

    A. Consumer
    B. Service locator
    C. Service provider
    D. Service provider interface
    E. None of the above

    Explanation :
    A. Option A is correct because a consumer has two dependencies. It requires both the service provider interface and the service locator.

25. Suppose you have these two JARs from Java 8. Which steps, when taken together, would be
    the best way to make them modules? (Choose two.)

        baby.otter
         |     ^
         V     |
        food.fish

    A. Add a module-info.java to each.
    B. Add them to the classpath.
    C. Create a third module to contain the common code.
    D. Merge them into one module to break the cyclic dependency.
    E. Rename the modules to use dashes instead of dots.

    Explanation :
    A,C. Option A is correct, and option B is incorrect as we want to create named modules when possible. 
    We also need to be on the lookout for cyclic dependencies. While option D would work, it is better to be more granular and create a third module as in option C. 
    Option E is incorrect because dots are used as separators in names.

26. Which command produces output such as the following?
    animal.puppy -> animal.dog
    A. jdeps –d zoo.animal.puppy.jar
    B. jdeps –s zoo.animal.puppy.jar
    C. jmod –d zoo.animal.puppy.jar
    D. jmod –s zoo.animal.puppy.jar
    E. None of the above

    Explanation :
    B. The jdeps command lists information about dependencies within a module. 
    The –s option provides a summary of output rather than verbose output, making option B the correct answer. 
    There is no –d option. The jmod command is for working with JMOD files.

27. Suppose the consumer, service locator, service provider, and service provider interface are
    each in separate modules. Which of the following best describes the following moduleinfo
    file?
    module nature.tree{
        requires nature.sapling;
        provides nature.sapling.Tree with nature.tree.Maple
    }

    A. Consumer
    B. Service locator
    C. Service provider
    D. Service provider interface
    E. None of the above

    Explanation :
    C. Option C is correct because a service provider requires the interface. It also provides the implementation.

28. Suppose we have module com.bird that contains package com.bird.tweet and
    class Tweety with a main() method. Which of the following can fill in the blank to run
    this program?
    java --module-path mods –module _____________

    A. com.bird.Tweety
    B. com.bird.tweety.Tweety
    C. com.bird/Tweety
    D. com.bird.tweet/Tweety
    E. com.bird/com.bird.tweet.Tweety
    F. com.bird.tweet/com.bird.Tweety

    Explanation :
    E. When running a module, the module name is listed before the slash, and the fully qualified class name is after the slash. 
    Option E is the only one that meets this criterion.

29. Which types of modules are required to contain a module-info file?

    A. Automatic only
    B. Named only
    C. Unnamed only
    D. Automatic and named
    E. Automatic and unnamed
    F. Named and unnamed

    Explanation :
    B. An unnamed module is on the classpath. While it is permitted to have a module-info file, the file is ignored if present. 
    An automatic module is on the module path and does not have a module-info file. 
    A named module is required to have a module-info file, making option B the correct answer.

30. Suppose the consumer, service locator, service provider, and service provider interface are
    each in separate modules. Which of the following best describes the following
    module-info file?

    module nature.tree{
        exports nature.tree.leaf;
        requires nature.sapling;
        uses nature.tree.Photosynthesis;
    }

    A. Consumer
    B. Service locator
    C. Service provider
    D. Service provider interface
    E. None of the above

    Explanation :
    B. Option B is correct because a service locator uses the interface. 
    It also requires the service provider interface module and exports the package with the locator.

31. What is a benefit of using modules? (Choose two.)

    A. Better access control
    B. Custom Java builds
    C. Elimination of JAR files
    D. Fewer .java files needed in your application
    E. Not necessary to specify types of local variables
    F. Write once, run anywhere

    Explanation :
    A,B. Option A is correct because modules provide a mechanism to export specific packages. 
    This creates module-level access since some packages can be used only in a module. 
    Option B is correct because jlink allows creating a distribution with just the parts of the JDK that are needed. 
    Option C is not correct because modules are usually distributed as a JAR file. 
    Option D is incorrect because modules actually require one extra file: module-info.java. 
    Option E is incorrect because var can be used with or without modules. 
    Finally, option F is incorrect because “write once, run anywhere” is a core benefit of Java independent of modules.

32. Suppose the consumer, service locator, service provider, and service provider interface are
    each in separate modules. Which of the following best describes the following
    module-info file?

    module nature.tree{
        requires nature.sapling;
    }

    A. Consumer
    B. Service locator
    C. Service provider
    D. Service provider interface
    E. None of the above

    Explanation :
    E. A consumer requires both the service locator and service provider interface. 
    A service locator and service provider interface need to have an exports statement. 
    A service provider needs a provides directive. Since none of them matches, option E is the correct answer.

33. Which types of modules are allowed to contain a module-info file?

    A. Automatic only
    B. Named only
    C. Unnamed only
    D. Automatic and named
    E. Automatic and unnamed
    F. Named and unnamed

    Explanation :
    F. An unnamed module is permitted to have a module-info file, but the file is ignored if present. 
    An automatic module does not have a module-info file. 
    A named module is required to have a module-info file. Therefore, option F is correct.

34. Which of the following is true of the following module declaration?
    1: class com.mammal {
    2:  exports com.mammal.cat;
    3:  exports cat.mammal.mouse to com.mice;
    4:  uses com.animal;
    5: }

    A. The first line that fails to compile is line 1.
    B. The first line that fails to compile is line 2.
    C. The first line that fails to compile is line 3.
    D. The first line that fails to compile is line 4.
    E. The code compiles.

    Explanation :
    A. A module-info file is required to start with module rather than class. 
    Therefore, the first line doesn’t compile, and option A is correct.

35. How many of these keywords can be used in a module-info.java file: closes, export,
    import, require, and uses?

    A. None
    B. One
    C. Two
    D. Three
    E. Four
    F. Five

    Explanation :
    B. You need to know these keywords: exports, requires, requires transitive, provides, opens, and uses. 
    Of these, only uses is in the list of candidates in the question. 
    Note that export and require are invalid because they should be exports and requires, respectively.

36. Suppose the consumer, service locator, service provider, and service provider interface are
    each in separate modules. Which of the following best describes the following
    module-info file?
    module nature.tree{
        exports nature.tree.leaf;
    }

    A. Consumer
    B. Service locator
    C. Service provider
    D. Service provider interface
    E. None of the above

    Explanation :
    D. Option D is correct because a service provider interface exposes the interface without depending on any of the other options.

37. Which of the following are modules supplied by the JDK? (Choose three.)
    A. jdk.base
    B. jdk.basic
    C. jdk.deskop
    D. jdk.javadoc
    E. jdk.jdeps
    F. jdk.net

    Explanation :
    D,E,F. The java.base module is automatically available to any module without specifying it. However, this question tries to trick you with option A by specifying jdk.base instead. 
    Similarly, java.desktop exists, but not jdk.deskop, making option C wrong. 
    Options D, E, and F are correct because jdk.javadoc , jdk.jdeps, and jdk.net are modules supplied with the JDK. 
    You do need to be able to recognize the names of built-in modules.

38. Which are true statements about types of migration? (Choose three.)

    A. All modules are immediately moved to the module path in a bottom-up migration.
    B. All modules are immediately moved to the module path in a top-down migration.
    C. Modules migrate before the modules that depend on them in a bottom-up migration.
    D. Modules migrate before the modules that depend on them in a top-down migration.
    E. Modules that are not yet named modules are automatic modules in a bottom-up migration.
    F. Modules that are not yet named modules are automatic modules in a top-down migration

    Explanation :
    B,C,F. A top-down migration starts by moving all the modules to the module path as automatic modules, making options B and F correct. 
    A bottom-up migration moves each module after all modules it depends on have been migrated, making option C correct.

39. A class in which of the following parts of a module service should include a method call to
    load(ChocolateLab.class) that would allow callers to use it?

    A. Consumer
    B. Service locator
    C. Service provider
    D. Service provider interface
    E. None of the above

    Explanation :
    B. The service locator contains a load() method, making option B correct.

40. How many of these module declarations are valid?
    module com.leaf {}
    module com.leaf2 {}
    module com-leaf { }
    module LEAF {}
    module leaf2 {}

    A. Zero
    B. One
    C. Two
    D. Three
    E. Four
    F. Five

    Explanation :
    E. Module names are permitted to be any valid variable name with the addition of dot separators (.). 
    The only one that is problematic is com-leaf because dashes are not allowed, making option E correct. 
    As a reminder, numbers are permitted as long as they are not the first character in a segment. Capital letters are discouraged but allowed.

41. Which is a benefit of ServiceLoader?
    A. It allows you to add functionality without recompiling the application.
    B. It allows you to load a service written in C++.
    C. It is an interface.
    D. When implementing a service, it references the ServiceLoader.

    Explanation :
    A. Option A is correct because ServiceLoader allows you to make your application extensible. 
    A service can be added without recompiling the entire application. 
    It is a class, but the service provider implementation does not reference it, making options C and D incorrect. 
    Option B is not a feature of Java.

42. Which are true statements? (Choose two.)

    A. Code on the classpath can reference code in automatic, named, and unnamed modules.
    B. Code on the classpath can reference code in named modules, but not automatic and unnamed modules.
    C. Code on the classpath can reference code in automatic and named modules, but not unnamed modules.
    D. Code on the module path can reference code in automatic, named, and unnamed modules.
    E. Code on the module path can reference code in named modules, but not automatic and unnamed modules.
    F. Code on the module path can reference code in automatic and named modules, but not unnamed modules.

    Explanation :
    A,F. Code on the classpath has not yet been migrated to modules and can reference any code in the application. 
    This is true whether that code is in automatic, named, or unnamed modules, matching option A. 
    Code on the module path operates in a stricter world and cannot reference code on the classpath. 
    Since unnamed modules cannot be accessed in this situation, option F is the second answer.

43. Suppose we have the packages in the diagram. What could we add to the
    module-info.java in com.duck to allow the com.park module to reference the
    Duckling class but not allow the com.bread module to do the same?

    _______________________________________________________
    com.duck                     |  com.bread             |
        com                      |      com               |
            duckling             |          bread         |
                Duckling.java    |              Food.java |
            egg                  |      module-info.java  |
                Egg.java         |________________________|
                                 |  com.park              |
        module-info.java         |      com               |
                                 |           park         |
                                 |              Grass.java|
                                 |      module-info.java  |
    -------------------------------------------------------

    A. exports com.duckling;
    B. exports com.duckling from com.park;
    C. exports com.duckling to com.park;
    D. exports com.park from com.duckling;
    E. exports com.park to com.duckling;
    F. None of the above

    Explanation :
    C. Option A is incorrect because it exports the package to all modules. Option C is correct because it limits package sharing to the com.park module. 
    Option E is incorrect because a package must be exported from the module that contains it. 
    Options B and D are incorrect because from is not valid syntax.

44. Given the diagram in the previous question, what could we add to module-info.java in
    com.duck to allow the com.park package to reference the Duckling class, but not allow
    the Egg class to reference the Duckling class?

    A. exports com.duckling;
    B. exports com.duckling from com.park;
    C. exports com.duckling to com.park;
    D. exports com.park from com.duckling;
    E. exports com.park to com.duckling;
    F. None of the above

    Explanation :
    F. It is not possible to provide access outside the module while also limiting access within the com.duck module. 
    Options A and C are tempting because they do provide access in com.park. 
    However, they do not prevent the Egg class in the com.egg package from accessing the com.duckling package. 
    Remember that the com.egg package is in the com.duck module, so the access cannot be restricted. 
    Therefore, option F is correct.

45. Given the diagram in question 43 and the correct export statement to share only com.
    duckling, which of the following should be included in the module-info.java file of
    com.park to specify that com.park should have access to the com.duckling and com.
    bread packages, but not the com.egg package?

    A. require com.duck, com.bread;
    B. requires com.duck; com.bread;
    C. require com.duckling, com.bread;
    D. requires com.duckling; com.bread;
    E. None of the above

    Explanation :
    E. The correct way to specify this is requires com.duck; requires com.bread;. There is no way to combine two module requires statements into one. 
    Additionally, note that the requires statement works with a module name, not a package name.

46. Which is both part of the service and has a provides directive?
    A. Consumer
    B. Service locator
    C. Service provider
    D. Service provider interface
    E. None of the above

    Explanation :
    E. Only the service provider has a provides directive. Since it is not part of the service, option E is the correct answer.

47. What command is the simplest way to list suggestions for classes in jdk.unsupported?

    A. jdeps cookie.jar
    B. jdeps –s cookie.jar
    C. jdeps –jdkinternals cookie.jar
    D. jdeps --jdkinternals cookie.jar
    E. jdeps -jdkunsupported cookie.jar
    F. jdeps --jdkunsupported cookie.jar

    Explanation :
    D. Both options A and B note that the JAR depends on the jdk.unsupported module. However, they do not list suggested replacements. 
    Options C and E are invalid because flags of this format need two dashes. 
    Option D is correct and option F is incorrect because the desired flag is --jdkinternals. 
    Note that --jdk-internals is also acceptable.

48. Which modules are on the classpath?
    A. Automatic only
    B. Named only
    C. Unnamed only
    D. Automatic and named
    E. Automatic and unnamed
    F. Named and unnamed

    Explanation :
    C. Option C is correct because only unnamed modules are on the classpath. 

49. Which line of code belongs in a service locator?

    A. ServiceLoader loader = ServiceLoader.load();
    B. ServiceLoader loader = ServiceLoader.load(Mouse.class);
    C. ServiceLoader<Mouse> loader = ServiceLoader.load();
    D. ServiceLoader<Mouse> loader = ServiceLoader.load(Mouse.class);
    E. Mouse loader = ServiceLoader.load();
    F. Mouse loader = ServiceLoader.load(Mouse .class);

    Explanation :
    D. The service locator contains a ServiceLoader call to look up the service loader. 
    It takes the type of class it looked up as a parameter and returns a generic, making option D the correct answer.

50. Which is true about a service? (Choose two.)

    A. Changing the service provider interface always requires recompiling the service provider.
    B. Changing the service provider interface sometimes requires recompiling the service provider.
    C. Changing the service provider interface never requires recompiling the service provider.
    D. If the service provider interface references other classes in the method signatures, they are considered part of the service.
    E. If the service provider interface references other classes in the method signatures, they are not considered part of the service.

    Explanation :
    B,D. Option B is correct because it depends on the change. 
    If a method is added to the service provider interface or a public method is changed, the service providers must be recompiled. 
    However, if a change is made that does not affect the service provider, such as a new static method, recompilation is not needed. 
    Option D is also correct because return types and parameter types are considered part of the service.

51. Which modules are on the module path?
    A. Automatic only
    B. Named only
    C. Unnamed only
    D. Automatic and named
    E. Automatic and unnamed
    F. Named and unnamed

    Explanation :
    D. Unnamed modules are on the classpath. Option D is correct because automatic and named modules are on the module path.

52. The service locator and service provider interface share a module. Which boxes represent the
    consumer and service provider, respectively?
    X
        Z
    Y

    A. X and Y
    B. X and Z
    C. Y and Z
    D. Z and Z
    E. Z and Y
    F. None of the above

    Explanation :
    F. The consumer needs to depend on the shared module, making it X. The shared module then has to be Z, and the service provider has to be Y. 
    However, the service provider should not know about the consumer, and the dotted line in the diagram does not make sense. 
    This means none of the options can create a valid scenario, and option F is the correct answer.

53. What command is the simplest way to list what modules a JAR depends on without listing
    package names?
    A. jdeps cookie.jar
    B. jdeps –s cookie.jar
    C. jdeps –jdkinternals cookie.jar
    D. jdeps --jdkinternals cookie.jar
    E. jdeps -jdk-unsupported cookie.jar
    F. jdeps --jdk-unsupported cookie.jar

    Explanation :
    B. Without any command line flags, jdeps lists packages and module dependencies. 
    The -s flag provides a summary omitting the package name, which means option B is the correct answer.

54. What is a benefit of using modules? (Choose three.)
    A. Ability to reuse code
    B. Clearer dependency management
    C. Improved performance
    D. Multithreading support
    E. Platform independence
    F. Unique package enforcement

    Explanation :
    B,C,F. Options A, D, and E are incorrect because they are benefits of Java even without modules. 
    Option B is correct because the module-info file clarifies dependencies. 
    Option C is correct because a smaller deployment package can be faster. 
    Finally, option F is correct because the module system prevents the same package from being used from multiple JAR files.

55. Fill in the blanks to list a way of getting a lot of information useful in debugging modules:
    _______ -m x –p y --______________

    A. jar and –show-modules
    B. jar and –show-module-detail
    C. jar and –show-module-resolution
    D. java and –show-modules
    E. java and –show-module-detail
    F. java and –show-module-resolution

    Explanation :
    F. The first clue is that the -m and -p options are on the java command. Beyond that, you need to memorize the name of the --show-module-resolution option.

56. Suppose you have the following interface in a module named animal.insect.api. What
    needs to be included in the module-info file for it to be a service provider interface?

    package animal.insect.api.bugs;
    public interface Bug {
        int crawl();
    }

    A. exports animal.insect.api;
    B. exports animal.insect.api.bugs;
    C. exports animal.insect.api.bugs.Bug;
    D. requires animal.insect.api;
    E. requires animal.insect.api.bugs;
    F. requires animal.insect.api.bugs.Bug;

    Explanation :
    B. This module is a service provider interface. The only requirement is that the module needs to export the package containing the interface. 
    In this case, that is the animal.insect.api.bugs package, which matches option B.

57. Suppose you have the following class in a module named animal.insect.impl and the
    service provider interface module from question 56. What needs to be included in the
    module-info for it to be a service provider? (Choose two.)

    package animal.insect.impl;
    import animal.insect.api.bugs.Bug;
    public class Worm implements Bug {
        @Override
        public int crawl() {
            return 1;
        }
    }

    A. requires animal.insect.api.bugs;
    B. requires animal.insect.lookup;
    C. requires animal.printer;
    D. provides animal.insect.impl.Worm;
    E. provides animal.insect.api.bugs.Bug with animal.insect.impl.Worm;
    F. provides animal.insect.impl.Worm with animal.insect.api.bugs.Bug;

    Explanation :
    A,E. This module is a service provider. It needs a requires directive for the service provider interface, which is option A. 
    It also needs a provides directive, which specifies both the interface and implementation. 
    Option E has both in the correct order.

58. Suppose you have the following class in a module named animal.insect.lookup, the
    service provider interface from question 56, and the service provider from question 57. What
    needs to be included in the module-info file besides an exports directive for it to be a
    service locator? (Choose two.)
    package animal.insect.lookup;

    import animal.insect.api.bugs.Bug;
    import java.util.List;
    import java.util.ServiceLoader;
    import java.util.stream.Collectors;

    public class InsectFinder {
        public static List<Bug> findAllBugs() {
            return ServiceLoader.load(Bug.class)
                .stream()
                .map(ServiceLoader.Provider::get)
                .collect(Collectors.toList());
        }
    }

    A. provides animal.insect.lookup;
    B. provides animal.insect.lookup.InsectFinder;
    C. requires animal.insect.api.bugs;
    D. requires animal.insect.api.Bug;
    E. uses animal.insect.api.bugs;
    F. uses animal.insect.api.bugs.Bug;

    Explanation :
    C,F. This module is a service locator. It needs three directives: exports, requires, and uses. 
    The requires directive specifies the module it depends on, which is option C. 
    The uses directive specifies the service provider interface it references, which is option F.

59. Suppose you have the following class in a module named animal.insect.printer, the
    service provider interface from question 56, the service provider from question 57, and the
    service locator from question 58. What needs to be included in the module-info for it to
    be a consumer? (Choose two.)

    package animal.printer;
    import animal.insect.lookup.InsectFinder;
    public class Print {
        public static void main(String[] args) {
            var bugs = InsectFinder.findAllBugs();
            bugs.forEach(System.out::println);
        }
    }

    A. requires animal.insect.api.bugs;
    B. requires animal.insect.lookup;
    C. requires animal.printer;
    D. uses animal.insect.api.bugs;
    E. uses animal.insect.api.bugs.Bug;
    F. uses animal.insect.lookup.InsectFinder;

    Explanation :
    A,B. This module is a consumer. It needs two requires directives. 
    Option A represents the service provider interface, and option B represents the service locator. 
    The uses directive should be in the service locator, not the consumer

60. What command is the simplest way to list what modules a JAR depends on including
    package names?

    A. jdeps cookie.jar
    B. jdeps –s cookie.jar
    C. jdeps –jdkinternals cookie.jar
    D. jdeps --jdkinternals cookie.jar
    E. jdeps -jdk-unsupported cookie.jar
    F. jdeps --jdk-unsupported cookie.jar

    Explanation :
    A. Without any command line flags, jdeps lists packages and module dependencies, making option A correct. 
    Option D will also list the packages; however, it is longer than option A.

61. How many modules are part of the cyclic dependency?
    module com.light {
        exports com.light;
    }
    module com.animal {
        exports com.animal;
        requires com.light;
        requires com.plant;
    }
    module com.plant {
        exports com.plant;
        requires com.light;
        requires com.animal;
    }
    module com.worm {
        exports com.worm;
        requires com.light;
        requires com.animal;
        requires com.plant;
    }

    A. 0
    B. 1
    C. 2
    D. 3
    E. 4

    Explanation :
    C. The com.light module does not have any dependencies, so it is fine. However, com.animal and com.plant depend on each other giving us a cyclic dependency. 
    Finally, com.worm depends on all the modules but does not introduce any more problems. 
    It will not compile until com.animal or com.plant are fixed, but is not part of the cycle itself. 
    Option C is correct, since only two modules are part of the cycle.

62. What is true about the -d option?
    A. It can be used with the jar command, but not the java command.
    B. It can be used with the java command, but not the jar command.
    C. It can be used with the jar and java commands and serves the same purpose for both.
    D. It can be used with the jar and java commands, but means “directory” for the former and “describe module” for the later.
    E. None of the above.

    Explanation :
    C. The -d option is a shorthand for --describe-module on both the jar and java commands. Therefore, option C is correct.

63. Assuming all referenced files and directories exist and are correct, what does this code do?
    javac –m mods –d mouse mouse/com/mouse/*.java
        mouse/module-info.java
    jar –cvf mods/com.mouse.jar –C mouse/ .

    A. Creates a JAR file representing the com.mouse module
    B. Creates a JAR file that is not a module
    C. Fails on the javac command
    D. Fails on the jar command

    Explanation :
    C. The javac command takes -p for the module path rather than -m. Since there is no –m on the javac command, option C is the correct answer

64. What module is always in the jdeps output?

    A. java.base
    B. java.lang
    C. java.self
    D. jdk.base
    E. jdk.lang
    F. jdk.self

    Explanation :
    A. Option B is tempting because the java.lang package is available to all classes. However, the question asks about modules. 
    Option A is the correct answer because the java.base module is available to all modules. 
    The other options are incorrect because those modules do not exist.

65. Which are valid modes on the jmod command? (Choose three.)
    A. create
    B. list
    C. hash
    D. show
    E. verbose
    F. version

    Explanation :
    A,B,C. The jmod command has five possible modes: create, extract, describe, list, and hash.

66. This diagram shows the second step of a migration to modules. What type of
    migration is this?

    classpath   |   module path
    butterfly   |
                |   caterpillar

    A. Bottom-up.
    B. Side-to-side.
    C. Top-down.
    D. There is not enough information to determine which type it is.

    Explanation :
    A. There is no such thing as a side-to-side migration, ruling out option B. In a top-down migration, all modules are moved to the module path first, making option C incorrect. 
    In a bottom-up migration, modules are moved, starting with those without dependencies. 
    Therefore, option A is correct.

67. Which are true statements about the diagram and scenario in the previous question?
    (Choose two.)

    A. butterfly is an automatic module.
    B. butterfly is a named module.
    C. butterfly is an unnamed module.
    D. caterpillar is an automatic module.
    E. caterpillar is a named module.
    F. caterpillar is an unnamed module.

    Explanation :
    C,E. In a bottom-up migration, the lowest-level modules are migrated to named modules on the module path first. 
    This makes option E one of the answers. 
    The modules that remain on the classpath are unnamed modules, making option C the other answer.

68. Suppose we have the two JARs in the diagram on the module path and the module-info
    in the com.magic jar only exports one package: com.magic.unicorn. There is no
    module-info file in the com.science JAR. How many of the four packages in the
    diagram can a third module on the module path access?

    ---------------------------------------------------
    | com.magic              |   com.science          |
    |--------------------------------------------------
    |    com.magic.dragon    |       com.science.bio  |
    |    com.magic.unicorn   |       com.science.chem |
    | module-info            |                        |
    ---------------------------------------------------

    A. 0
    B. 1
    C. 2
    D. 3
    E. 4

    Explanation :
    D. The com.magic module exports only one package. This makes the com.magic.unicorn package accessible, but not the com.magic.dragon package. 
    Both packages in com.science are accessible because it is an automatic module. 
    When a module on the module path does not contain a module-info file, all packages are exported. 
    This gives us three packages that are accessible and a correct answer of option D.

69. Suppose the two JARs described in the previous question are on the classpath. How many of
    the four packages in the diagram can a module on the module path access?

    A. 0
    B. 1
    C. 2
    D. 3
    E. 4

    Explanation :
    A. Modules on the module path cannot access anything from the classpath, 
    making option A the correct answer.

70. What is true about the following module-info.java file?
    module Book { }

    A. It does not compile because it is empty.
    B. It does not compile because the module name is uppercase.
    C. It does not compile because the module name has only one component.
    D. It does not compile for another reason.
    E. It compiles.

    Explanation :
    E. Option E is correct as this code does compile. While it is uncommon, a module is not required to have any directives in the body. 
    Similarly, module names are lowercase and have more than one component by convention. 
    None of these problems prevents the file from compiling, though.

71. When adding a new service provider, which of these do you need to recompile?

    A. Consumer
    B. Service locator
    C. Existing service providers
    D. Service provider interface
    E. None of the above

    Explanation :
    E. One of the benefits of services is not having to recompile existing code when adding a new implementation. 
    This makes option E the correct answer.

72. When working with modules, what option names are equivalent to -m and -s?

    A. --module and --short
    B. --module and --statistics
    C. --module and --summary
    D. --module-path and --short
    E. --module-path and --statistics
    F. --module-path and --summary

    Explanation :
    C. The java command uses -m and --module to supply the module name. 
    The jdeps command uses -s and --summary to specify the output should be limited. 
    Option C matches both of these.

73. Which are considered part of a service?

    A. Classes referenced by the implementation, but not the interface
    B. Classes referenced by the interface, but not the implementation
    C. Classes referenced by either the implementation or the interface
    D. None of the above

    Explanation :
    B. A service is comprised of the interface, any classes the interface references, and a way to look up implementations of the interface. 
    It does not include the implementation. This makes option A the correct answer.

74. Which commands have the options -m and –s to represent modules and summary,
    respectively?

    A. javac and jar
    B. javac and jdeps
    C. javac and jmod
    D. java and jar
    E. java and jdeps
    F. java and jmod

    Explanation :
    E. Option E is correct because both java and jdeps meet the criteria. 
    The jar command does as well although the options mean different things than working with modules.

75. Suppose you have the following class in a module named animal.insect.impl. Which
    two most likely go in the module-info of the service locator? (Choose two.)
    
    package animal.insect.impl;
    
    import animal.insect.api.bugs.Bug;
    
    public class Worm implements Bug {
        @Override
        public int crawl() {
            return 1;
        }
    }

    A. requires animal.insect.api.bugs;
    B. requires animal.insect.api.bugs.Bug;
    C. requires animal.insect.impl;
    D. uses animal.insect.api.bugs;
    E. uses animal.insect.api.bugs.Bug;
    F. uses animal.insect.api.bugs.Bug with animal.insect.impl.Worm;

    Explanation :
    A,E. This question is tricky because the service provider code is shown, but the question 
    asks about the service locator, and you need to infer information about the service provider 
    interface. The requires directive is option A due to process of elimination. 
    Option B is incorrect because the requires directive references a module name rather than an interface. 
    Option C is incorrect because we need the service provider interface module, and it refers to the service provider module. 
    Option E is easier, since the uses directive works with an interface name.

76. Which statements are true? (Choose two.)

    A. A bottom-up migration has more steps involving the classpath than a top-down migration.
    B. A top-down migration has more steps involving the classpath than a bottom-up migration.
    C. Both types of migration have the same number of steps involving the classpath.
    D. A bottom-up migration has unnamed modules on the module path
    E. A top-down migration has unnamed modules on the module path.
    F. Neither migration type has unnamed modules on the module path.

    Explanation :
    A,F. A bottom-up migration leaves unnamed modules on the classpath until they are migrated to the module path, making option A correct and option D incorrect. 
    A top-down migration immediately moves all modules to the module path as automatic modules making options B and E incorrect. 
    Therefore, option F is the other correct answer.

77. Fill in the blank with code to look up and call a service.
    String cheese = ServiceLoader.load(Mouse.class)
    .stream()
    .map(______________)
    .map(Mouse::favoriteFood)
    .findFirst()
    .orElse("");

    A. Mouse.get()
    B. Mouse::get
    C. Provider.get()
    D. Provider::get
    E. None of the above

    Explanation :
    D. The ServiceLoader class has a load() method that returns a Collection of Provider. 
    Option D is correct because we need to convert the Provider into a Mouse.

78. Given the diagram, what statements need to be in module-info.java for the mammal
    module? (Choose three.)
    ________________________________________
    |  animal           |   mammal         |
    |   animal.util     |    mammal.eat    |
    |                   |                  |
    ---------------------------------------- 
    | milk              |   panda          |
    |   milk.store      |     panda.food   |
    |                   |                  |
    ----------------------------------------

    A. exports mammal;
    B. exports mammal.eat;
    C. requires animal;
    D. requires animal.util;
    E. requires milk;
    F. requires milk.store;

    Explanation :
    B,C,E. The mammal module depends on two other modules. Since requires references module names, options C and E are correct. 
    The module also has one package, which is referenced in the exports directive. This makes option B correct as well.

79. Given the previous diagram and the following module-info.java for the panda module,
    what change can be made to the requires statement?

    module panda {
        requires mammal;
    }

    A. exports transitive mammal;
    B. exports transitive mammal.eat;
    C. requires transitive animal;
    D. requires transitive animal.util;
    E. transitive requires animal;
    F. transitive requires animal.util;

    Explanation :
    C. The transitive keyword goes after requires, ruling out all but options C and D. 
    Just like requires, requires transitive references a module name, narrowing it down to option C.

80. Given the diagram in question 78 and the following module-info.java for the panda
    module, what is the result of including line m1?

    module panda {
        requires mammal;
        requires transitive mammal; // line m1
    }

    A. Any modules that require mammal will automatically get panda as well.
    B. Any modules that require panda will automatically get mammal as well.
    C. There is no change in behavior.
    D. The code does not compile.

    Explanation :
    D. Any requires directives must reference unique modules. 
    Using the transitive keyword does not change this requirement, making option D the correct answer.

81. How many service providers are allowed to implement a service provider interface and have
    the consumer reference the first one?

    A. Exactly one
    B. Exactly two
    C. One or two
    D. One or more
    E. None of the above

    Explanation :
    D. There can be multiple service providers for a single service provider interface, making option D the correct answer.

82. Which of the following are modules supplied by the JDK? (Choose three.)

    A. java.logging
    B. java.javadoc
    C. java.jdk
    D. java.management
    E. java.naming
    F. java.scripts

    Explanation :
    A,D,E. The java.logging, java.management, and java.naming modules exist, making options A, D, and E correct. 
    Option B is tempting. However, jdk.javadoc exists, not java.javadoc. Options C and F are completely made up.

83. Which are true of a JAR file that has only one module-info.class file, placed in the
    META-INF directory? (Choose two.)

    A. It is an automatic module if on the classpath.
    B. It is an automatic module if on the module path.
    C. It is a named module if on the classpath.
    D. It is a named module if on the module path.
    E. It is an unnamed module if on the classpath.
    F. It is an unnamed module if on the module path.

    Explanation :
    B,E. Option E is correct because all modules on the classpath are unnamed modules. 
    On the module path, we can have automatic or named modules. 
    In this case, it is an automatic module because there is no module-info.class at the root of the JAR. 
    Having that file in another directory is ignored. This makes option B the other answer.

84. The service locator and service provider interface share a module. Which boxes represent the
    consumer and service provider, respectively?

    X
        Z
    Y

    A. X and Y
    B. X and Z
    C. Y and Z
    D. Z and Z
    E. Z and Y
    F. None of the above

    Explanation:
    A. The consumer needs to depend on the shared module, making it X. 
    The shared module then has to be Z, and the service provider has to be Y. 
    This makes option A correct.

85. What statements are most accurate about the ServiceLoader class? (Choose two.)

    A. load() does not take any parameters.
    B. load() takes the class type as a parameter.
    C. When looping through the results of load(), you need to call the get() method on Provider.
    D. When using the results of load() in a Stream, you need to call the get() method on Provider.

    Explanation :
    B,D. The method call of ServiceLoader.load(Poodle.class), takes a parameter making option B correct and option A incorrect. 
    When using a Stream, you call Provider::get, making option D the other answer. 
    Option C is incorrect because you don’t need to call the get() method when using a loop.

86. Suppose we have an automatic module on the module path named
    lizard-^-cricket-^-1.0.0-SNAPSHOT.jar and no Automatic-Module-Name
    specified. What module name should named modules use to reference it?

    A. lizard-cricket
    B. lizard.cricket
    C. lizard-cricket-SNAPSHOT
    D. lizard-cricket.SNAPSHOT
    E. None of the above

    Explanation :
    B. The rules for determining the name include removing the extension, removing numbers and changing special characters to periods (.). 
    Additionally, we remove the version information from the end, which is 1.0.0-SNAPSHOT. 
    Finally, we normalize the duplicate dots, which gives us option B: lizard.cricket. 

87. What file formats are legal for a module to be distributed?

    A. jar
    B. jmod
    C. zip
    D. jar and jmod
    E. jar and zip
    F. jmod and zip

    Explanation :
    D. The jar file format is most common. The JMOD jmod format is used as well. 
    Therefore, option D is correct.

88. Why is this module-info incorrect for a service provider?

    module plant.flower {
        exports plant.flower.impl;
        requires plant.flower.api;
        provides plant.flower.api.Petal
            with plant.flower.impl.PetalImpl;
    }

    A. The exports directive should be export.
    B. The exports directive should not be present because all calls to the service provider should use the service locator.
    C. The provides directive should be uses instead.
    D. The provides directive has the implementation and interface in the wrong order.
    E. The requires directive should be exports instead.
    F. The requires directive should not be present because provides implies it.

    Explanation :
    B. Option B is correct because a service provider should not contain an exports directive. 
    The service locator is used to reference any implementation exposed by provides.

89. How many modules are part of the cyclic dependency?

    module.com.light {
        exports com.light;
    }
    module com.plant {
        exports com.plant;
        requires com.light;
        requires com.animal;
    }
    module com.animal {
        exports com.animal;
        requires com.light;
    }
    module com.worm {
        exports com.worm;
        requires com.light;
        requires com.animal;
        requires com.plant;
    }

    A. 0
    B. 1
    C. 2
    D. 3
    E. 4

    Explanation :
    A. The com.light module is a dependency for all the other modules but does not depend on them. 
    Similarly, the com.animal module is a dependency for the two higher-level modules but does not depend on them. 
    Finally, the com.plant module is a dependency for the com.worm module but does not depend on it. 
    While the modules are not defined in this order, the question is about cyclic dependencies rather than order of compilation. 
    There is no cyclic dependency, making option A correct.

90. What statements are true about requires mandated java.base? (Choose two.)

    A. This output is expected when running the java --list-modules command.
    B. This output is expected when running the java --show-module-resolution command.
    C. This output is expected when running the jdeps command.
    D. This output is expected when running the jmod command.
    E. All modules will include this in the output.
    F. Some modules will include this in the output.

    Explanation :
    C,E. The jdeps command outputs requires mandated java.base except when run in summary mode, making option C correct. 
    Since this module is an implicit dependency in all modules, option E is also correct.


