
1. The following figure represents a stream pipeline. Given this, would the boxes X, Y, Z best
    represent?
        X   --->    Y   --->    Z

    A. Origin, intermediate operation, and final operation
    B. Origin, intermediate operation, and sink
    C. Origin, intermediate operation, and terminal operation
    D. Source, intermediate operation, and final operation
    E. Source, intermediate operation, and sink
    F. Source, intermediate operation, and terminal operation

    Explanation :
    F. The source is the first operation, and the terminal operation comes last, making option F the answer. You need to know this terminology.

2. Which of the following is required for all valid lambda expressions?

    A. ()
    B. ->
    C. {}
    D. Parameter data type(s)
    E. None of the above

    Explanation :
    B. The lambda expression s -> true is valid, making options A, C, and D incorrect. 
    Parentheses, (), are not required on the left-hand side if there is only one variable. 
    Braces, {}, are not required if the right-hand side is a single expression. 
    Parameter data types are only required if the data type for at least one parameter is specified; otherwise, none are required. 
    The remaining choice, the arrow operator, ->, is required for all lambda expressions, 
    making option B the correct answer.

3. Fill in the blanks: The ______________ functional interface does not take any inputs, while
    the ______________ functional interface does not return any data.

    A. IntConsumer, LongSupplier
    B. IntSupplier, Function
    C. Supplier, DoubleConsumer
    D. UnaryOperator, Consumer
    E. None of the above

    Explanation :
    C. The Supplier functional interface does not take any inputs, while the Consumer functional interface does not return any data. 
    This behavior extends to the primitive versions of the functional interfaces, making option C the correct answer. 
    Option A is incorrect because IntConsumer takes a value, while LongSupplier returns a value. 
    Options B and D are incorrect because Function and UnaryOperator both take an input and produce a value.

4. What is the result of executing the following application multiple times?
    package bears;
    import java.util.*;
    public class Bounce {
        public static void main(String... legend) {
        List.of(1,2,3,4).stream()
            .forEach(System.out::println);
        List.of(1,2,3,4).parallel()
            .forEach(System.out::println);
        List.of(1,2,3,4).parallel()
            .forEachOrdered(System.out::println);
    } }

    A. Only the first stream prints the same order every time.
    B. Only the first and second streams print the same order every time.
    C. Only the first and third streams print the same order every time.
    D. All of the streams print the same order every time.
    E. None of the streams prints the same order every time.
    F. None of the above.

    Explanation :
    F. A List instance, which inherits the Collection interface, does not have a parallel() method. 
    Instead, parallelStream() must be used, making option F correct. 
    If the code was corrected to use parallelStream(), then the first and third streams would be consistently printed in the same order. 
    Remember that the forEachOrdered() method forces parallel streams to run in sequential order. 
    The order of the second operation would be unknown ahead of time, since it uses a parallel stream.

5. A lambda expression for which of the following functional interfaces could be used to return
    a Double value? (Choose two.)

    A. UnaryOperator
    B. BiPredicate
    C. BiOperator
    D. BiConsumer
    E. BiFunction
    F. BiSupplier

    Explanation :
    A,E. The UnaryOperator and BiFunction return a generic argument, such as Double, making options A and E correct. 
    Option B is incorrect because all predicate functions return boolean. 
    Option C is incorrect because BiOperator does not exist in the java.util.function package. The correct name is BinaryOperator. 
    Option D is incorrect because all consumer functions return void. 
    Finally, option F is incorrect because BiSupplier does not exist in the java.util.function package. 
    Supplier functions return values, and Java does not support methods with more than one return type.

6. What does the following output?

    var list = new ArrayList<String>();
    list.add("Austin");
    list.add("Boston");
    list.add("San Francisco");
    var c = list.stream()
        .filter(a -> a.length() > 10) // line x
        .count();
    System.out.println(c + " " + list.size());

    A. 1 1
    B. 1 3
    C. 2 3
    D. The code does not compile due to line x.
    E. None of the above.

    Explanation :
    B. The stream pipeline is correct and filters all values out that are 10 characters or smaller. 
    Only San Francisco is long enough, so c is 1. 
    The stream() call creates a new object, so stream operations do not affect the original list. 
    Since the original list is still 3 elements, 
    option B is correct.

7. Identify the correct functional interfaces to fill in this table correctly. (Choose three.)
    _________________________________________________________
    |   Functional Interface    |      Possible Return Type |
    _________________________________________________________
    |   Interface               |      X Boolean            |
    |   Interface               |      Y int                |
    |   Interface               |      Z Void               |
    ---------------------------------------------------------

    A. Interface X is Predicate.
    B. Interface X is Supplier.
    C. Interface Y is Comparator.
    D. Interface Y is Supplier.
    E. Interface Z is Consumer.
    F. Interface Z is Supplier.

    Explanation :
    B,C,E. Interface X is tricky. If it returned a boolean primitive, option A would be correct as Predicate returns a boolean. 
    However, it returns a wrapper object, so it has to be a Supplier, making option B the answer instead.
    Interface Y and Z are more straightforward as a Comparator and Consumer, respectively. 
    This makes options C and E the final two answers

8. What is a common reason for a stream pipeline not to run?

    A. The source doesn’t generate any items.
    B. There are no intermediate operations.
    C. The terminal operation is missing.
    D. The version of Java is too old.
    E. None of the above.

    Explanation :
    C. Option A is incorrect because a pipeline still runs if the source doesn’t generate any items and the rest of the pipeline is correct. 
    Granted, some of the operations have nothing to do, but control still passes to the terminal operation. 
    Option B is incorrect because intermediate operations are optional. 
    Option C is the answer. The terminal operation triggers the pipeline to run. 
    Option D is incorrect because the code would not compile at all if the version of Java were too old.

9. Which functional interface takes a long value as an input argument and has an
    accept() method?

    A. LongConsumer
    B. LongFunction
    C. LongPredicate
    D. LongSupplier
    E. None of the above

    Explanation :
    A. The LongSupplier interface does not take any input, making option D incorrect. It also uses the method name getAsLong(). 
    he rest of the functional interfaces all take a long value but vary on the name of the abstract method they use. 
    LongFunction contains apply() and LongPredicate contains test(), making options B and C, respectively, incorrect. 
    That leaves us with LongConsumer, which contains accept(), making option A the correct answer.

10. Given a parallel Stream<T>, which method would you use to obtain an equivalent serial
    Stream<T>?

    A. unordered()
    B. reduce()
    C. concat()
    D. stream()
    E. boxed()
    F. None of the above

    Explanation :
    F. The correct method to obtain an equivalent sequential stream of an existing stream is sequential(), which is inherited by any class that implements BaseStream<T>. 
    Since this isn’t an option, option F is correct. 
    Note that unordered() creates a stream that can be evaluated in any order, but it can still be processed in a sequential or parallel stream.

11. Which of the following is a valid lambda expression?

    A. r -> {return 1==2}
    B. (q) -> true
    C. (x,y) -> {int test; return test>0;}
    D. a,b -> true
    E. None of the above

    Explanation :
    B. Option A is incorrect because the lambda expression is missing a semicolon (;) at the end of the return statement. 
    Option C is incorrect because the local variable test is used without being initialized. Option D is also incorrect. 
    The parentheses are required on the left-hand side of the lambda expression when there is more than one value or a data type is specified. 
    Option B is the correct answer and the only valid lambda expression.

12. Which are true of the following? (Choose two.)
    var empty = Optional.empty();
    var param = Optional.of(null);
    var method = Optional.ofNullable(null);

    A. All of these will run without error.
    B. One of the lines fails to compile or throws an exception.
    C. Two of the lines fail to compile or throw an exception.
    D. None of these returns true when calling opt.isPresent()
    E. One of these returns true when calling opt.isPresent()
    F. Two of these return true when calling opt.isPresent()

    Explanation :
    B,D. The second line throws a NullPointerException when you pass a null reference to the of() method. The others compile and run successfully, making option B correct. 
    The first and third lines return false because they represent an empty Optional. This makes option D the other answer

13. Which of the following statements about DoubleSupplier and Supplier<Double>
    is not true?

    A. Both are functional interfaces.
    B. Both take zero parameters.
    C. Lambdas for both can return a double value.
    D. Lambdas for both cannot return a null value.
    E. One supports a generic type; the other does not.
    F. All of these are true.

    Explanation :
    D. Both are functional interfaces in the java.util.function package, making option A true. 
    Additionally, both lack parameters, making option B true. 
    The major difference between the two is that Supplier<Double> takes the generic type Double, while the other does not take any generic type and instead uses the primitive double. 
    For this reason, options C and E are true statements. For Supplier<Double> in option C, remember that the returned double value can be implicitly autoboxed to Double. Option D is the correct answer. 
    Lambdas for Supplier<Double> can return a null value since Double is an object type, while lambdas for DoubleSupplier cannot; they can only return primitive double values.

14. What is the output of the following program?
    import java.util.stream.*;
    public class Bull {
        void charge() {
            IntStream.range(1,6)
                .parallel()
                .forEachOrdered(System.out::print);
        }
        public static void main(String[] args) {
            var b = new Bull();
            b.charge();
        }
    }

    A. 12345
    B. 54321
    C. The output cannot be determined ahead of time.
    D. The code does not compile.
    E. An exception is thrown at runtime.
    F. None of the above.

    Explanation :
    A. Even though a parallel stream is used, the forEachOrdered() method forces the stream to operate in the order of its data source. 
    The code compiles and runs without issue rinting 12345 every time, and making option A correct. 
    If forEach() was used instead, then the output would vary at runtime.

15. Fill in the blank with the functional interface from java.util.function that allows the
    code to compile and print 3 at runtime.

    _____________ transformer = x -> x;
    var prime = List.of(3,1,4,1,5,9)
        .stream()
        .limit(1)
        .peek(s -> {})
        .mapToInt(transformer)
        .peek(s -> {})
        .sum();
    System.out.println(prime);

    A. Function<Integer,Integer>
    B. UnaryOperator<Integer>
    C. ToIntFunction<Integer>
    D. IntUnaryOperator
    E. The code does not compile regardless of what functional interface is placed in the blank.
    F. The code is capable of compiling, but since prime is an OptionalInt value, it cannot be 3 at runtime.

    Explanation :
    C. The first line that contains the lambda expression will actually compile with any of the functional interfaces listed in the options. 
    The stream operation, though, will compile only if ToIntFunction<Integer> is used. 
    It requires this functional interface, which takes a generic argument and returns int. For this reason, option C is correct. 
    Option F is incorrect because sum() on an IntStream returns an int, not an OptionalInt. 
    Note that the peek() operations in this stream have no effect.

16. Which fills in the blank so the code is guaranteed to print 1?
    var stream = Stream.of(1, 2, 3);
    System.out.println(stream.__________);

    A. anyMatch()
    B. findAny()
    C. first()
    D. min()
    E. None of the above

    Explanation :
    E. Option A is incorrect because anyMatch() returns a boolean. 
    Option B is incorrect because findAny() might not return 1. The result could be any of the three numbers. 
    Option C is incorrect because there is no first() method available as a terminal operation. 
    Option D is tempting because there is a min() method. However, since we are working with a Stream (not a primitive stream like IntStream), 
    this method requires a Comparator as a parameter. Therefore, option E is the answer.

17. What is the result of the following?

    6: var list = new ArrayList<String>();
    7: list.add("Monday");
    8: list.add(String::new);
    9: list.add("Tuesday");
    10: list.remove(0);
    11: System.out.println(list.get(0));

    A. null
    B. An empty String.
    C. Monday
    D. The code does not compile.
    E. The code compiles but throws an exception at runtime.

    Explanation :
    D. Line 8 does not compile. String::new is a constructor reference. 
    This constructor reference is equivalent to writing the lambda () -> new String(). It participates in deferred execution. 
    When it is executed later, it will return a String. 
    It does not return a String on line 8, though. The method reference is a Supplier<String>, which cannot be stored in list. 
    Since the code does not compile, option D is correct.

18. Which functional interface, when filled into the blank, allows the class to compile?
    package space;
    import java.util.function.*;
    public class Asteroid {
        public void mine(___________ lambda) {
            // IMPLEMENTATION OMITTED
        }
        public static void main(String[] debris) {
            new Asteroid().mine((s,p) -> s+p);
        }
    }

    A. BiConsumer<Integer,Double>
    B. BiConsumer<Integer,Double,Double>
    C. BiFunction<Integer,Double,Double>
    D. BiFunction<Integer,Integer,Double>
    E. Function<Integer,Double>
    F. None of the above

    Explanation :
    C. The lambda (s,p) -> s+p takes two arguments and returns a value. For this reason, options A and B are incorrect because BiConsumer does not return any values. 
    Option E is also incorrect, since Function takes only one argument and returns a value. 
    This leaves us with options C and D, which both use BiFunction, which takes two generic arguments and returns a generic value. 
    Option D is incorrect because the datatype of the unboxed sum s+q is int, and int cannot be both autoboxed and implicitly cast to Double. 
    Option C is correct. The sum s+p is of type double, and double can be autoboxed to Double.

19. What best describes a reduction?

    A. A source operation that creates a small value
    B. An intermediate operation where it filters the stream it receives
    C. An intermediate operation where it mathematically divides each element in the stream
    D. A terminal operation where a single value is generated by reading each element in the prior step in a stream pipeline
    E. A terminal operation where one element is returned from the prior step in a stream pipeline without reading all the elements

    Explanation :
    D. The word reduction is used with streams for a terminal operation, so options A, B, and C are incorrect. 
    Option E describes a valid terminal operation like anyMatch(), but is not a reduction. 
    Option D is correct because a reduction has to look at each element in the stream to determine the result.

20. Which statements about the following application are correct? (Choose two.)
    import java.util.concurrent.atomic.AtomicInteger;
    import java.util.stream.IntStream;

    public class TicketTaker {
        long ticketsSold;
        final AtomicInteger ticketsTaken;

        public TicketTaker() {
            ticketsSold = 0;
            ticketsTaken = new AtomicInteger(0);
        }
        public void performJob() {
            IntStream.iterate(1, p -> p+1)
                    .parallel()
                    .limit(100)
                    .forEach(i -> ticketsTaken.getAndIncrement());
            IntStream.iterate(1, q -> q+1)
                    .parallel()
                    .limit(500)
                    .forEach(i -> ++ticketsSold);
            System.out.print(ticketsTaken+" "+ticketsSold);
        }
        public static void main(String[] matinee) {
            new TicketTaker().performJob();
        }
    }

    A. The TicketTaker constructor does not compile.
    B. The performJob() method does not compile.
    C. The class compiles.
    D. The first number printed is consistently 100.
    E. The second number printed is consistently 500.
    F. A ConcurrentModificationException is thrown at runtime.

    Explanation :
    C,D. The class compiles and runs without throwing an exception, making option C correct 
    and options A, B, and F incorrect. The class defines two values that are incremented by multiple threads in parallel. The first IntStream statement uses an atomic class to update a 
    variable. Since updating an atomic numeric instance is thread-safe by design, the first number 
    printed is always 100, making option D correct. The second IntStream statement uses an 
    int with the pre-increment operator (++), which is not thread-safe. It is possible two threads 
    could update and set the same value at the same time, a form of race condition, resulting in a 
    value less than 500 and making option E incorrect.

21. Suppose you have a stream with one element and the code
    stream.xxxx.forEach(System.out::println). Filling in xxxx from top to bottom
    in the table, how many elements can be printed out? Assume a valid lambda expression is
    passed to each method in the table.
    Method Number elements printed

    filter() ?
    flatMap() ?
    map() ?

    A. Zero or one, zero or more, exactly one
    B. Zero or one, exactly one, zero or more
    C. Zero or one, zero or more, zero or more
    D. Exactly one, zero or more, exactly one
    E. Exactly one, exactly one, zero or more
    F. Exactly one, zero or more, zero or more

    Explanation :
    A. The filter() method either passes along a given element or doesn’t, making options D, E, and F incorrect. 
    The flatMap() method doesn’t pass along any elements for empty streams. For nonempty streams, it flattens the elements, allowing it to return zero or more elements. This makes option B incorrect. 
    Finally, the map() method applies a one-to-one function for each element. 
    It has to return exactly one element, so option A is the correct answer.

22. Assuming the proper generic types are used, which lambda expression can be assigned to a
    ToDoubleBiFunction functional interface reference? (Choose three.)

    A. (Integer a, Double b) -> {int c; return b;}
    B. (h,i) -> (long)h
    C. (String u, Object v) -> u.length()+v.length()
    D. (x,y) -> {int z=2; return y/z;}
    E. z -> z
    F. (double y, double z) -> y + z

    Explanation :
    A,B,D. To begin with, ToDoubleBiFunction<T,U> takes two generic inputs and returns a double value. 
    Option A is correct because it takes an Integer and Double and returns a Double value that can be implicitly unboxed to double. 
    Option B is correct because long can be implicitly cast to double. While we don’t know the data types for the input arguments, we know that some values, such as using Integer for both, will work. 
    Option C cannot be assigned and does not compile because the variable v is of type Object and Object does not have a length() method. 
    Option D is correct. The variable y could be declared Double in the generic argument to the functional interface, making y/z a double return value. 
    Option E is not correct because the lambda only has one parameter. 
    Finally, option F is incorrect because the interface uses the class Double rather than primitive double.

23. Given a Stream<T>, which method would you use to obtain an equivalent parallel
    Stream<T>?

    A. getParallelStream()
    B. parallelStream()
    C. parallel()
    D. getParallel()
    E. parallels()
    F. None of the above

    Explanation :
    C. The correct method to obtain an equivalent parallel stream of an existing stream is parallel(), which is inherited by any class that implements BaseStream<T>. 
    For this reason, option C is correct.

24. Rewrite this lambda that takes an int n using a constructor reference:

    n -> new ArrayList<>(n)

    A. ArrayList::new
    B. ArrayList::new()
    C. ArrayList::new(n)
    D. ArrayList::new[n]
    E. None of the above

    Explanation :
    A. The lambda is a Function<Integer, ArrayList>. We need a constructor reference that uses the new keyword where a method name would normally go in a method reference. 
    It can implicitly take zero or one parameters just like a method reference. In this case, we have one parameter, which gets passed to the constructor. 
    Option A is correct. Options B, C, and D use syntax that is not supported with method references.

25. On a DoubleStream, how many of the methods average(), count(), max(), and
    sum() return an OptionalDouble?

    A. None
    B. One
    C. Two
    D. Three
    E. Four

    Explanation :
    C. The average() method returns an OptionalDouble. This reflects that it doesn’t make sense to calculate an average when you don’t have any numbers. 
    Similarly, max() returns an OptionalDouble because there isn’t a maximum of no number. 
    By contrast, counting without any numbers gives the long number 0 and summing gives the double number 0.0. 
    Since only two methods matches the desired return type, option C is correct.

26. Which of the following is not a functional interface in the java.util.function package?
    (Choose two.)

    A. BiPredicate
    B. DoubleUnaryOperator
    C. IntUnaryOperator
    D. ObjectDoubleConsumer
    E. ObjectIntConsumer
    F. ToLongFunction

    Explanation :
    D,E. The BiPredicate interface takes two generic arguments and returns a boolean value. 
    Next, DoubleUnaryOperator and IntUnaryOperator exist and transform values of type double and int, respectively. 
    Last, ToLongFunction takes a generic argument and returns a long value. That leaves options D and E, which is the answer. 
    While there are ObjDoubleConsumer and ObjIntConsumer functional interfaces, there is no such thing as ObjectDoubleConsumer or ObjectIntConsumer. 
    Remember that Object is abbreviated to Obj in all functional interfaces in java.util.function.

27. Five of the following six methods always produce the same result whether they are executed
    on an ordered serial or parallel stream. Which one does not?

    A. findAny()
    B. findFirst()
    C. limit()
    D. skip()
    E. anyMatch()
    F. count()

    Explanation :
    A. The findAny() method can return the first, last, or any element of the stream, regardless of whether the stream is serial or parallel. 
    While on serial streams this is likely to be the first element in the stream, on parallel streams the result is less certain. 
    For this reason, option A is the correct answer. The anyMatch() and count() methods produce the same result, regardless of whether the stream is serial or parallel. 
    The rest of the operations force the stream to behave in a sequential manner when applied to an ordered stream, even if it is parallel. 
    Note that the behavior is not the same on an unordered stream. 
    For example, findFirst() can return any element when applied to an unordered stream

28. In a stream pipeline, which can return a value other than a Stream?

    A. Source
    B. Intermediate operation
    C. Terminal operation
    D. None of the above

    Explanation :
    C. The result of the source and any intermediate operations are chained and eventually passed to the terminal operation. 
    The terminal operation is where a nonstream result is generated, making option C correct.

29. When working with a Stream<String>, which of these types can be returned from the
    collect() terminal operator by passing arguments to Collectors.groupingBy()?

    A. Only Map<Boolean, HashSet<String>>
    B. Only Map<Integer, List<String>>
    C. Both Map<Boolean, HashSet<String>> and Map<Integer, List<String>>
    D. Only List<Integer>
    E. Only List<String>
    F. Both List<Integer> and List<String>

    Explanation :
    C. The groupingBy() collector always returns a Map (or a specific implementation class of Map), so options D, E, and F are incorrect. 
    The other two are definitely possible. To get one, you can group using a Function that returns an Integer such as s.collect(groupingBy(String::length)). 
    To get the other, you need to group using a Function that returns a Boolean and specify the type, such as s.collect(groupingBy(String::isEmpty, toCollection(HashSet::new))). 
    Therefore, option C is correct.

30. What does the following output?

    12: Set<String> set = new HashSet<>();
    13: set.add("tire-");
    14: List<String> list = new LinkedList<>();
    15: Deque<String> queue = new ArrayDeque<>();
    16: queue.push("wheel-");
    17: Stream.of(set, list, queue)
    18:     .flatMap(x -> x)
    19:     .forEach(System.out::print);

    A. [tire-][wheel-]
    B. tire-wheel-
    C. [wheel-][tire-]
    D. wheel-tire-
    E. None of the above.
    F. The code does not compile.

    Explanation :
    F. The flatMap() method works with streams rather than collections. Line 18 is problematic because the return value is not a stream. 
    Since the code does not compile, option F is correct. If the lambda was changed to x -> x.stream(), option B would be the answer

31. What is the result of executing the following?

    var list = new LinkedList<>();
    list.add("Archie");
    list.add("X-Men");
    Stream s = list.stream(); // line w
    s.forEach(System.out::println);
    s.forEach(System.out::println);

    A. The code runs without exception and prints two lines.
    B. The code runs without exception and prints four lines.
    C. The code does not compile due to line w.
    D. The code does not compile due to another line.
    E. The code compiles but throws an exception at runtime.

    Explanation :
    E. Since no generic type is specified, list is a LinkedList<Object>. Line w compiles because no generic type is specified. 
    However, Java only allows you to operate on a stream once. 
    The final line of code throws an IllegalStateException because the stream has already been used up, making option D correct.

32. What is the output of the following application?
    package zoo;
    public class TicketTaker1 {
        private static int AT_CAPACITY = 100;
        public int takeTicket(int currentCount,
                            IntUnaryOperator<Integer> counter) {
            return counter.applyAsInt(currentCount);
        }
        public static void main(String...theater) {
            final TicketTaker bob = new TicketTaker();
            final int oldCount = 50;
            final int newCount = bob.takeTicket(oldCount,t -> {
                if(t>AT_CAPACITY) {
                    throw new RuntimeException(
                            "Sorry, max has been reached");
                }
                return t+1;
            });
            System.out.print(newCount);
        }
    }

    A. 50
    B. 51
    C. The code does not compile because of the lambda expression.
    D. The code does not compile for a different reason.
    E. The code compiles but prints an exception at runtime.

    Explanation :
    D. The code does not compile, so options A, B, and E are incorrect. 
    The IntUnaryOperator functional interface is not generic, so the argument IntUnaryOperator<Integer> in the takeTicket() does not compile, making option D the correct answer. 
    he lambda expression compiles without issue, making option C incorrect. 
    If the generic argument <Integer> was dropped from the argument declaration, the class would compile without issue and output 51 at runtime, making option B the correct answer.

33. What are the three requirements for performing a parallel reduction with the collect()
    method, which takes a Collector argument. (Choose three.)

    A. The Collector argument is marked concurrent.
    B. The elements of the stream implement the Comparable interface.
    C. The stream is parallel.
    D. The stream is thread-safe.
    E. The stream or Collector is marked unordered.
    F. The stream is not a primitive stream.

    Explanation :
    A,C,E. Options A, C, and E are the precise requirements for Java to perform a concurrent reduction using the collect() method, which takes a Collector argument. 
    Recall from your studies that a Collector is considered concurrent and unordered if it has the Collector.Characteristics enum values CONCURRENT and UNORDERED, respectively. 
    The rest of the options are not required for a parallel reduction.

34. What is true about the following code? (Choose two.)

    27: public static void main(String[] s) {
    28:     Predicate dash = c -> c.startsWith("-");
    29:     System.out.println(dash.test("–"));
    30:
    31:     Consumer clear = x -> System.out.println(x);
    32:     clear.accept("pink");
    33:
    34:     Comparator<String> c = (String s, String t) -> 0;
    35:     System.out.println(c.compare("s", "t"));
    36: }

    A. The code compiles successfully.
    B. One line does not compile.
    C. Two lines do not compile.
    D. Three lines do not compile.
    E. If any lines that do not compile are fixed, the output includes pink.
    F. If any lines that do not compile are fixed, the output does not include pink.

    Explanation :
    C,E. While it is common for a Predicate to have a generic type, it is not required. However, it is treated like a Predicate of type Object if the generic type is missing. 
    Since startsWith() does not exist on Object, line 28 does not compile.
    Line 34 would be a correct lambda declaration in isolation. However, it uses the variable s, which is already taken from the main() method parameter. 
    This causes a compiler error on line 34. These are the only two compiler errors, making option C correct. 
    If Predicate were changed to Predicate<String> and lambda variable were changed to x, the Consumer would in fact print pink, making option E the other answer.

35. Which functional interface returns a primitive value?

    A. BiPredicate
    B. CharSupplier
    C. LongFunction
    D. UnaryOperator
    E. TriDoublePredicate
    F. None of the above

    Explanation :

    A. Option A is the correct answer because BiPredicate takes two generic types and returns a primitive boolean value. 
    Option B is incorrect, since CharSupplier does not exist in java.util.function. 
    Option C is also incorrect, since LongFunction takes a primitive long value and returns a generic type. 
    Remember, Java only includes primitive functional interfaces that operate on double, int, or long. 
    Option D is incorrect because UnaryOperator takes a generic type and returns a generic value. 
    Finally, option E is incorrect because TriDoublePredicate is not a built-in functional interface.

36. Given the following code snippet, which lambda expressions are the best choices for an accumulator?
    (Choose two.)
    import java.util.*;
    import java.util.function.*;
    public class GoodAccumulator {
        int i = 0;
        List<String> words = new ArrayList<>();
        public void test() {
            BiFunction<Integer,Integer,Integer> x = _____________;
            System.out.print(List.of(1,2,3,4,5)
                .parallelStream()
                .reduce(0,x,(s1, s2) -> s1 + s2));
        } }

    A. (a,b) -> (a-b)
    B. (a,b) -> 5
    C. (a,b) -> i++
    D. (a,b) -> {words.add("awesome"); return 0;}
    E. (a,b) -> {return 0;}
    F. (a,b) -> words.add("awesome")

    Explanation :
    B,E. An accumulator in a serial or parallel reduction should be associative and stateless. In a parallel reduction, problematic accumulators tend to produce more visible errors. 
    Option A is not associative, since (a-b)-c is not the same as a-(b-c) for all values a, b, and c. 
    Options C and D are incorrect because they represent stateful lambda expressions, which should be avoided especially on parallel streams. 
    Option F doesn’t even compile, since the return type is a boolean, not an Integer. 
    That leaves us with the correct answers, options B and E.
    While these accumulators may not seem useful, they are both stateless and associative, which meets the qualifications for performing a reduction.

37. Fill in the blanks so that both methods produce the same output for all inputs.
    private static void longer(Optional<Boolean> opt) {
        if (opt.___________())
            System.out.println("run: " + opt.get());
    }
    private static void shorter(Optional<Boolean> opt) {
        opt.map(x -> "run: " + x)
            ._________(System.out::println);
    }

    A. isNotNull, isPresent
    B. ifPresent, isPresent
    C. isPresent, forEach
    D. isPresent, ifPresent
    E. None of the above

    Explanation :
    D. The Optional class has an isPresent() method that doesn’t take any parameters. It returns a boolean and is commonly used in if statements. 
    There is also an ifPresent() method that takes a Consumer parameter and runs it only if the Optional is nonempty. 
    The methods isNotNull() and forEach() are not declared in Optional. Therefore, option D is correct.

38. Rewrite this lambda using a method reference:

    () -> Math.random()
    A. Math.random
    B. Math::random
    C. Math::random()
    D. java.lang::Math.random
    E. None of the above

    Explanation :
    B. The lambda is a Supplier<Double>. Since the random() method is static, we need a static method reference. 
    It uses :: to separate the class name and method name. Option B is correct. 
    Options A, C, and D use syntax that is not supported with method references.

39. Which operation can occur more than once in a stream pipeline?

    A. Origin
    B. Sink
    C. Source
    D. Intermediate operation
    E. Terminal operation
    F. None of the above

    Explanation :
    D. Options A and B are incorrect because they are not operations in a stream pipeline. 
    A source and the terminal operation are required parts of a stream pipeline and must occur exactly once. 
    The intermediate operation is optional. It can appear zero or more times. 
    Since more than once falls within zero or more, option D is correct.

40. What is true of the following code?

    21: var list = List.of('c', 'b', 'a');
    22:
    23: list.stream()
    24:     .sorted()
    25:     .findAny()
    26:     .ifPresent(System.out::println);
    27:
    28: System.out.println(list.stream().sorted().findFirst());

    A. Both streams are guaranteed to print the single character a.
    B. Both streams will print a single character of a, b, or c.
    C. Only one stream is guaranteed to print the single character a.
    D. Only one stream will print a single character of a, b, or c.
    E. The code does not compile.

    Explanation :
    D. All of the code compiles. The first stream source has three elements. The intermediate operations both sort the elements of this stream and then we request one from findAny(). 
    The findAny() method is not guaranteed to return a specific element. Since we are not using parallelization, it is highly likely that the code will print a. However, you need to know this is not guaranteed. 
    Additionally, the stream on line 28 prints Optional[a], Optional[b], or Optional[c]. Since only lines 23–26 print a single character, option D is the answer.

41. Which functional interface, when entered into the following blank, allows the class
    to compile?

    package groceries;
    import java.util.*;
    import java.util.function.*;
    public class Market {
        private static void checkPrices(List<Double> prices,
                ____________ scanner) {
            prices.forEach(scanner);
        }
        public static void main(String[] right) {
            List<Double> prices = List.of(1.2, 6.5, 3.0);
            checkPrices(prices,
                p -> {
                    String result = p<5 ? "Correct" : "Too high";
                    System.out.println(result);
                });
        }
    }

    A. Consumer
    B. Consumer<Integer>
    C. DoubleConsumer
    D. Supplier<Double>
    E. None of the above

    Explanation :
    E. First, the forEach() method requires a Consumer instance. Option D can be immediately discarded because Supplier<Double> does not inherit Consumer. 
    For this same reason, option C is also incorrect. DoubleConsumer does not inherit from Consumer. 
    In this manner, primitive functional interfaces cannot be used in the forEach() method. 
    Option A seems correct, since forEach() does take a Consumer instance, but it is missing a generic argument. 
    Without the generic argument, the lambda expression does not compile because the expression p<5 cannot be applied to an Object. 
    Option B is also close, however, a Double cannot be passed to an Integer. 
    The correct functional interface is Consumer<Double>, and since that is not available, option E is the correct answer.

42. Which of the following is not a valid lambda expression?

    A. (Integer j, k) -> 5
    B. (p,q) -> p+q
    C. (Integer x, Integer y) -> x*y
    D. (left,right) -> {return "null";}
    E. All of these are valid.

    Explanation :
    A. Option A is the invalid lambda expression because the type is specified for the variable j, but not the variable k. 
    The rest of the options are valid lambda expressions. 
    To be a valid lambda expression, the type must be specified for all of the variables, as in option C, or none of them, as in options B and D.

43. What is the output of the following application?
    package exercise;
    import java.util.*;
    public class Concat {
        public String concat1(List<String> values) {
            return values.parallelStream()
                    .reduce("a",
                            (x,y)->x+y,
                            String::concat);
        }
        public String concat2(List<String> values) {
            return values.parallelStream()
                    .reduce((w,z)->z+w).get();
        }
        public static void main(String... questions) {
            Concat c = new Concat();
            var list = List.of("Cat","Hat");
            String x = c.concat1(list);
            String y = c.concat2(list);
            System.out.print(x+" "+y);
        }
    }

    A. CatHat CatHat
    B. aCataHat HatCat
    C. The code does not compile because the stream in concat1() returns an Optional.
    D. The code does not compile for a different reason.
    E. An exception is printed at runtime.
    F. None of the above.

    Explanation :
    B. The code compiles and runs without issue. The three-argument reduce() method returns a generic type, while the one-argument reduce() method returns an Optional. 
    The concat1() method is passed an identity "a", which it applies to each element, resulting in the reduction to aCataHat. 
    The lambda expression in the concat2() method reverses the order of its inputs, leading to a value of HatCat. 
    For these reasons, option B is the correct answer.

44. Which of the following three functional interfaces is not equivalent to the other two?

    A. BiFunction<Double,Double,Double>
    B. BinaryOperator<Double>
    C. DoubleFunction<Double>
    D. None of the above. All three are equivalent.

    Explanation :
    C. BiFunction<Double,Double,Double> and BinaryOperator<Double> both take two Double input arguments and return a Double value, making them equivalent to one another. 
    On the other hand, DoubleFunction<Double> takes a single double value and returns a Double value. 
    For this reason, it is different from the other two, making option C correct and option D incorrect.

45. Given the following code snippet, what changes should be made for the JVM to correctly
    process this as a concurrent reduction? (Choose two.)
    var w = Stream.of("c","a","t")
        .collect(HashSet::new, Set::add, Set::addAll);
    System.out.println(w);

    A. Replace HashSet with LinkedHashSet.
    B. Mark the stream parallel.
    C. Remove the second argument of the collect() method.
    D. Remove the third argument of the collect() method.
    E. Replace HashSet with ConcurrentSkipListSet.
    F. Mark the stream unordered.

    Explanation :
    B,E. For a concurrent reduction, the underlying type should be a thread-safe collection. For this reason, option A is incorrect and option E is correct. 
    The streams must all be parallel, making option B correct and option F incorrect. 
    Options C and D are incorrect, as there is no two-argument version of collect() within the Stream interface.

46. Fill in the blank so this code outputs three lines:
    var list = new ArrayList<String>();
    list.add("Atlanta");
    list.add("Chicago");
    list.add("New York");
    list.stream()
        .filter( ___________ )
        .forEach(System.out::println);

    A. String::isEmpty
    B. ! String::isEmpty
    C. String::! isEmpty
    D. String::isNotEmpty
    E. None of the above

    Explanation :
    E. Option A is the only one of the three options to compile. However, it results in no lines being output since none of the three strings is empty. 
    Options B and C do not even compile because a method reference cannot have an operator next to it. 
    Option D does not compile because String does not have an isNotEmpty() method. Therefore, option E is correct.

47. What does the following output?
    var chars = Stream.generate(() -> 'a');
    chars.filter(c -> c < 'b')
        .sorted()
        .findFirst()
        .ifPresent(System.out::print);

    A. a
    B. The code runs successfully without any output.
    C. The code does not complete.
    D. The code compiles but throws an exception at runtime.

    Explanation :
    C. The source of this stream is infinite. Sorting something infinite never finishes, so the stream pipeline never completes. This corresponds to option C.

48. What is the expected output of the following code snippet?
    Stream.iterate(1, x -> x + 1)
        .limit(5)
        .skip(2)
        .peek(System.out::print)
        .collect(Collectors.toList())
        .forEach(System.out::print);

    A. It does not compile.
    B. It throws an exception at runtime.
    C. It does not print any output at runtime.
    D. 345345
    E. 334455
    F. The behavior of the code snippet cannot be determined until runtime.

    Explanation :
    D. The code compiles and does not throw any exception at runtime, so options A and B are incorrect. 
    The code snippet is serial, by default, so the order is predictable, making option F incorrect. 
    The peek() method executes on each member of the pipeline, printing five numbers as the elements are then collected into a List, which gives us 345. 
    They are then printed again, making the final output 345345 and option D correct.

49. What is the output of the following program?
    package ai;
    import java.util.function.*;
    public class Android {
        public void wakeUp(Supplier supplier) { // d1
            supplier.get();
        }
        public static void main(String... electricSheep) {
            Android data = new Android();
            data.wakeUp(() -> System.out.print("Started!")); // d2
        }
    }

    A. Started!
    B. The code does not compile because of line d1 only.
    C. The code does not compile because of line d2 only.
    D. The code does not compile because of both lines d1 and d2.

    Explanation :
    C. The program does not compile, so option A is incorrect. The Supplier functional interface normally takes a generic argument, 
    although generic types are not strictly required, since they are removed by the compiler. 
    Therefore, line d1 compiles while triggering a compiler warning, and options B and D are incorrect. 
    On the other hand, line d2 does cause a compiler error, because the lambda expression does not return a value. 
    Therefore, it is not compatible with Supplier, making option C the correct answer.

50. Given the following code snippet, what statement about the values printed on lines p1 and p2
    is correct?

    var db = Collections.synchronizedList(new ArrayList<>());
    IntStream.range(1,6)
        .parallel()
        .map(i -> {db.add(i); return i;})
        .forEachOrdered(System.out::print); // p1
    System.out.println();
    db.forEach(System.out::print); // p2

    A. They are always the same.
    B. They are sometimes the same.
    C. They are never the same.
    D. The code does not compile.
    E. The code will produce a ConcurrentModificationException at runtime.
    F. None of the above.

    Explanation :
    B. First, the class uses a synchronized list, which is thread-safe and allows modification from multiple threads, making option E incorrect. 
    The process generates a stream of numbers from 1 to 5 and sends them into a parallel stream where the map() is applied, possibly out of order. 
    This results in elements being written to db in a random order. The stream then applies the forEachOrdered() method to its elements, which will force the parallel stream into a single-threaded state. 
    At runtime, line p1 will print the results in order every time as 12345. 
    On the other hand, since the elements were added to db in a random order, the output of line p2 is random and cannot be predicted ahead of time. 
    Since the results may sometimes be the same, option B is the correct answer. 
    Part of the reason that the results are indeterminate is that the question uses a stateful lambda expression, which, based on your studies, should be avoided.

51. Fill in the blanks so this code prints *8.0-8.0*? (Choose two.)

    var ints = IntStream.of(6, 10);
    var longs = ints.mapToLong(i -> i);
    var first = longs.________________;
    var moreLongs = LongStream.of(6, 10);
    var stats = moreLongs.summaryStatistics();
    var second = _________________________;
    System.out.println("*" + first + "-" + second + "*");

    A. averageAsDouble() in the first blank
    B. average().getAsDouble() in the first blank
    C. getAverage().get() in the first blank
    D. stats.average() in the second blank
    E. stats.average().get() in the second blank
    F. stats.getAverage() in the second blank

    Explanation :
    B,F. Primitive streams, like LongStream, declare an average() method that returns an OptionalDouble object. This object declares a getAsDouble() method rather than a get() method. 
    Therefore, option A is incorrect, and option B is correct.
    By contrast, the summary statistics classes provide getters in order to access the data. 
    The getAverage() method returns a double and not an OptionalDouble, which makes option F correct. The other options do not compile.

52. Starting with DoubleConsumer and going downward, fill in the missing values for
    the table.
    -------------------------------------------------------------
    Functional Interface    |   # Parameters in Method Signature
    -------------------------------------------------------------
    DoubleConsumer          |
    IntFunction             |
    LongSupplier            |
    ObjDoubleConsumer       |

    A. 0, 1, 1, 1
    B. 0, 1, 0, 2
    C. 0, 2, 1, 2
    D. 1, 1, 0, 2
    E. 1, 1, 1, 1
    F. None of the above

    Explanation :
    D. Remember that all Supplier interfaces take zero parameters. For this reason, the third value in the table is 0, making options A, C, and E incorrect. 
    Next, DoubleConsumer and IntFunction each take one value, double and int, respectively. 
    On the other hand, ObjDoubleConsumer takes two values, a generic value and a double, and returns void. 
    For this reason, option D is correct, and option B is incorrect.

53. Starting with DoubleConsumer and going downward, fill in the values for the table. For the
    following choices, assume R is a generic type.

    ------------------------------------------
    Functional Interface    |   Return Type
    ------------------------------------------
    DoubleConsumer          |
    IntFunction             |
    LongSupplier            |
    ObjDoubleConsumer       |

    A. double, int, long, R
    B. double, R, long, R
    C. R, int, long, R
    D. R, int, long, void
    E. void, int, R, void
    F. void, R, long, void

    Explanation :
    F. All Consumer functional interfaces have a void return type. For this reason, the first and last values in the table are both void, making options A, B and C incorrect. 
    IntFunction takes an int and returns a generic value, ruling out option D. Finally, LongSupplier does not take any values and returns a long value. 
    For this reason, option E is incorrect, and option F is correct

54. What is a possible output of the following application?
    import java.util.*;
    import java.util.stream.*;
    public class Car {
        private String model;
        private int year;
        @Override public String toString() {return model;}
        // Constructor/Getters/Setters Omitted
        public static void main(String... make) {
            var cars = new ArrayList<Car>();
            cars.add(new Car("Mustang",1967));
            cars.add(new Car("Thunderbird",1967));
            cars.add(new Car("Escort",1975));
            var map = cars
                    .stream()
                    .collect(
                            Collectors.groupingByConcurrent(Car::getYear));
            System.out.print(map);
        }
    }

    A. {1975=[Escort], 1967=[ Mustang, Thunderbird]}
    B. {Escort=[1975], Thunderbird=[1967], Mustang=[1967]}
    C. The code does not compile.
    D. The code hangs indefinitely at runtime.
    E. The application throws an exception at runtime because the stream is not parallel.
    F. None of the above.

    Explanation :
    A. The code compiles and runs without issue. The JVM will fall back to a single-threaded process if all of the conditions for performing the parallel reduction are not met. 
    The stream used in the main() method is not parallel, but the groupingByConcurrent() method can still be applied without throwing an exception at runtime. 
    Although performance will suffer from not using a parallel stream, the application will still process the results correctly. 
    Since the process groups the data by year, option A is the correct answer.

55. How many lines does this code output?

    var list = new LinkedList<String>();
    list.add("Archie");
    list.add("X-Men");
    list.stream().forEach(System.out.println);
    list.stream().forEach(System.out.println);

    A. Two.
    B. Four.
    C. The code does not compile.
    D. The code compiles but throws an exception at runtime.

    Explanation :
    C. This code is almost correct. Calling two different streams is allowed. The code attempts to use a method reference when calling the forEach() method. 
    However, it does not use the right syntax for a method reference. A double colon needs to be used. 
    The code would need to be changed to System.out::println to work and print two lines for each call. 
    Since it does not compile, option C is correct.

56. Which lambda expression can replace the instance of new BiologyMaterial() in the
    Scientist class and produce the same results under various inputted values?
    package university;
    @FunctionalInterface interface Study {
    abstract int learn(String subject, int duration);
    }
    class BiologyMaterial implements Study {
        @Override public int learn(String subject, int duration) {
            if(subject == null)
                return duration;
            else
                return duration+1;
        }
    }
    public class Scientist {
        public static void main(String[] courses) {
            final Study s = new BiologyMaterial();
            System.out.print(s.learn(courses[0],
                    Integer.parseInt(courses[1])));
        }
    }

    A. (p,q) -> q==null ? p : p+1
    B. (c,d) -> {int d=1; return c!=null ? d+1 : d;}
    C. (x,y) -> {return x==null ? y : y+1;}
    D. (a,b) -> 1
    E. None of the above

    Explanation :
    C. First, option A does not compile, since the variables p and q are reversed, making the return type of the method and usage of operators invalid. 
    The first argument p is a String and q is an int, but the lambda expression reverses them, and the code does not compile. Option B also does not compile. 
    The variable d is declared twice, first in the lambda argument list and then in the body of the lambda expression. 
    The second declaration in the body of the lambda expression causes the compiler to generate a duplicate local variable message. 
    Note that other than it being used twice, the expression is valid; the ternary operator is functionally equivalent to the learn() method in the BiologyMaterial class. 
    Option C is the correct answer since it compiles and handles the input in the same way as the learn() method in the BiologyMaterial class. 
    Option D compiles but does not return the same result.

57. What is true of the following? (Choose two.)
    var s = Stream.of("speak", "bark", "meow", "growl");
    BinaryOperator<String> merge = (a, b) -> a;
    var map = s.collect(toMap(String::length, k -> k, merge));
    System.out.println(map.size() + " " + map.get(4));

    A. The output is 2 bark.
    B. The output is 2 meow.
    C. The output is 4 bark.
    D. The output is 4 meow.
    E. If "meow" was replaced by a null reference, the output would remain the same.
    F. If "meow" was replaced by a null reference, the output would change.

    Explanation :
    A,F. This code does compile. Remember that imports are implied, including the static import for Collectors. 
    The collector tries to use the number of characters in each stream element as the key in a map. 
    This works fine for the first two elements, speak and bark, because they are of length 5 and 4, respectively. 
    When it gets to meow, it sees another key of 4. The merge function says to use the first one, so it chooses bark for the value. 
    Similarly, growl is 5 characters, but the first value of speak is used. There are only two distinct lengths, so option A is correct.
    If the stream had a null instead of "meow", the code would throw a NullPointerException, since we need to check the length of the String to determine which part of the Map it goes in. 
    Since you cannot call a method on null, option F is correct.

58. Which statement about a source in a Stream is true?

    A. The source is mandatory in a stream pipeline.
    B. The source is only allowed to return primitives.
    C. The source must be retrieved by calling the stream() method.
    D. The source must return a finite number of elements.
    E. None of the above.

    Explanation :
    A. Option A is correct as the source and terminal operation are mandatory parts of a stream pipeline. Option B is incorrect because a Stream must return objects. 
    Specialized interfaces like IntStream are needed to return primitives. 
    Option C is incorrect because Stream has methods such as of() and iterate() that return a Stream. 
    Option D is incorrect because infinite streams are possible.

59. Given an IntStream, which method would you use to obtain an equivalent parallel
    Stream<T>?
    A. parallel()
    B. parallelStream()
    C. parallels()
    D. getParallel()
    E. getParallelStream()
    F. None of the above

    Explanation :
    F. Trick question! The correct method to obtain an equivalent parallel stream of an existing IntStream is parallel(), 
    but for an IntStream this returns another IntStream, not a generic Stream<T>. For this reason, option F is correct.

60. Which can fill in the blank to have the code print true?
    var stream = Stream.iterate(1, i -> i+1);
    var b = stream.________(i -> i > 5);
    System.out.println(b);

    A. anyMatch
    B. allMatch
    C. noneMatch
    D. None of the above

    Explanation :
    A. This code generates an infinite stream of integers: 1, 2, 3, 4, 5, 6, 7, etc. The Predicate checks if the element is greater than 5. 
    With anyMatch(), the stream pipeline ends once element 6 is hit, and the code prints true. 
    For the allMatch() operator, it sees that the first element in the stream does not match, and the code prints false. 
    Similarly, the noneMatch() operator gets to the point where i is 6 and returns false because there is a match. 
    Therefore, option A is correct.

61. Which of the following fills in the blank so that the code outputs one line but uses a
    poor practice?
    import java.util.*;
    public class Cheater {
        int count = 0;
        public void sneak(Collection<String> coll) {
            coll.stream()._____________________________;
        }
        public static void main(String[] args) {
            var c = new Cheater();
            c.sneak(Arrays.asList("weasel"));
        }
    }

    A. peek(System.out::println)
    B. peek(System.out::println).findFirst()
    C. peek(r -> System.out.println(r)).findFirst()
    D. peek(r -> {count++; System.out.println(r); }).findFirst()
    E. None of the above compile.
    F. None of these are bad practice.

    Explanation :
    D. Option A is incorrect because it doesn’t print out one line. The peek() method is an intermediate operation. 
    Since there is no terminal operation, the stream pipeline is not executed, so the peek() method is never executed, and nothing is printed. 
    Options B and C are incorrect because they correctly output one line using a method reference and lambda, respectively, and don’t use any bad practices. 
    Option D is the correct answer. It does output one line. However, it is bad practice to have a peek() method that has side effects like modifying a variable.

62. What is the output of the following application?
    package nesting;
    import java.util.function.*;
    public class Doll {
        private int layer;
        public Doll(int layer) {
            super();
            this.layer = layer;
        }
        public static void open(
                UnaryOperator<Doll> task, Doll doll) {
            while((doll = task.accept(doll)) != null) {
                System.out.print("X");
            }
        }
        public static void main(String[] wood) {
            open(s -> {
                if(s.layer<=0) return null;
                else return new Doll(s.layer--);
            }, new Doll(5));
        }
    }

    A. XXXXX
    B. The code does not compile because of the lambda expression.
    C. The code does not compile for a different reason.
    D. The code compiles, but produces an infinite loop at runtime.
    E. The code compiles, but throws an exception at runtime.

    Explanation :
    C. The code does not compile, so option A, D, and E are incorrect. The lambda expression compiles without issue, making option B incorrect. 
    The task variable is of type UnaryOperator<Doll>, with the abstract method apply(). There is no accept() method defined on that interface, therefore the code does not compile, and option C is the correct answer. 
    If the code was corrected to use the apply() method, the rest of it would compile without issue. At runtime, it would then produce an infinite loop. 
    On each iteration of the loop, a new Doll instance would be created with 5, since the post-decrement (--) operator returns the original value of the variable, and that would be option D.

63. What is the expected output of the following code snippet?

    Random r = new Random();
    Stream.generate(r::nextDouble)
        .skip(2)
        .limit(4)
        .sorted()
        .peek(System.out::println)
        .forEach(System.out::println);

    A. It does not compile.
    B. It throws an exception at runtime.
    C. It does not print any output at runtime.
    D. It prints four numbers twice each.
    E. It can print up to eight distinct numbers.
    F. The behavior of the code snippet cannot be determined until runtime.

    Explanation :
    D. The code compiles and does not throw any exception at runtime, so options A and B are incorrect. 
    As an element goes through the pipeline, it is printed once by the peek() method, then once by the forEach() method. 
    For example, 0.1 0.1 0.54 0.54 0.6 0.6 0.3 0.3 is a possible output from this code. For this reason, option D is correct.

64. Which statements about the findAny() method applied to a stream are correct?
    (Choose three.)

    A. It always returns the first element on an ordered serial stream.
    B. It may return any element on an ordered serial stream.
    C. It always returns the first element on an unordered stream.
    D. It may return any element on an unordered stream.
    E. It always returns the first element on an ordered parallel stream.
    F. It may return any element on an ordered parallel stream.

    Explanation :
    B,D,F. The findAny() method is capable to return any element of the stream regardless of whether it is serial, parallel, ordered, or unordered. 
    For this reason, options B, D, and F are correct. Option C is actually invalid, as an unordered stream does not have a first element.

65. Which functional interface has a get() method?
    A. Consumer
    B. Function
    C. Supplier
    D. UnaryOperator
    E. None of the above

    Explanation :
    C. To begin with, Consumer uses accept(), making option A incorrect. Next, Function and UnaryOperator use apply(), making options B and D, respectively, incorrect. 
    Finally, Supplier uses get(), making option C the correct answer.

66. Why can’t String::charAt be used as a method reference within a Function?
    A. Method references can only be used on static methods.
    B. The charAt() method takes an int rather than Integer parameter.
    C. The method reference is not compatible with Function.
    D. The method reference syntax is illegal.
    E. There is no charAt() method in the String class.
    F. None of the above.

    Explanation :
    C. Option D is incorrect as the syntax is fine. 
    Option E is incorrect because there is a charAt() instance method. 
    While option B is correct that the method takes in an int parameter, autoboxing would take care of conversion for us if there were no other problems. 
    So, option B is not the answer either. 
    Option A is not true because there are constructor and instance method references. 
    This method reference could be assigned to BiFunction<String,Integer, Character>. 
    However, it cannot be assigned to a Function. This makes option C the correct answer

67. Given the following independent stream operations, which statements are correct?

    (Choose three.)
    List.of(2,4,6,8)
        .parallel()
        .parallelStream()
        .forEach(System.out::print);
    List.of(2,4,6,8)
        .parallelStream()
        .parallel()
        .forEach(System.out::print);
    List.of(2,4,6,8)
        .parallelStream()
        .parallel().parallel().parallel()
        .forEach(System.out::print);

    A. The first stream operation compiles.
    B. The second stream operation compiles.
    C. The third stream operation compiles.
    D. None of the stream operations that compile produce an exception at runtime.
    E. At least one of the stream operations that compiles produces at exception at runtime.
    F. The output of the stream operations that compile is consistent between executions.

    Explanation :
    B,C,D. While the second and third stream operations compile, the first does not. The parallel() method should be applied to a stream, while the parallelStream() method should be applied to a Collection<E>. 
    For this reason, option A is incorrect, and options B and C are correct. Neither the second or third stream operation are expected to produce an exception at runtime, making option D correct and option E incorrect. 
    Note that calling parallel() on an already parallel stream is unnecessary but allowed. 
    Finally, the output of the second and third stream operations will vary at runtime since the streams are parallel, making option F incorrect.

68. Which method reference can replace the lambda on the first line so the output is the same?
    BiPredicate<String, String> pred = (a, b) -> a.contains(b);
    System.out.println(pred.test("fish", "is"));

    A. a::contains(b)
    B. a::contains
    C. String::contains(b)
    D. String::contains
    E. The supplied code does not compile.
    F. None of the above.
    
    Explanation :
    D. Since the code uses a BiPredicate, it takes two parameters in the test() call. The first is the instance of String and the second is the substring value to check. 
    Since both parameters are passed in, we use the type of String in the method reference, making option D the correct answer.

69. What is the result of the following?
    import static java.util.stream.Collectors.*;
    import java.util.stream.Stream;
    class Ballot {
        private String name;
        private int judgeNumber;
        private int score;
        public Ballot(String name, int judgeNumber, int score) {
            this.name = name;
            this.judgeNumber = judgeNumber;
            this.score = score;
        }
    // all getters and setters
    }
    public class Speaking {
        public static void main(String[] args) {
            Stream<Ballot> ballots = Stream.of(
                    new Ballot("Mario", 1, 10),
                    new Ballot("Christina", 1, 8),
                    new Ballot("Mario", 2, 9),
                    new Ballot("Christina", 2, 8)
            );
            var scores = ballots.collect(
                    groupingBy(Ballot::getName,
                            summingInt(Ballot::getScore)));
            System.out.println(scores.get("Mario"));
        }
    }

    A. 2
    B. 18
    C. 19
    D. 110
    E. The code does not compile.

    Explanation :
    C. This code compiles. It creates a stream of Ballot objects. Then it creates a map with the contestant’s name as the key and the sum of the scores as the value. 
    For Mario, this is 10 + 9, or 19, so option C is correct.

70. Which of the following can fill in the blank to have the code print 44?

    var stream = Stream.of("base", "ball");
    stream.________(s -> s.length()).forEach(System.out::print);

    A. Only map
    B. Only mapToInt
    C. Only mapToObject
    D. Both map and mapToInt
    E. Both map and mapToObject
    F. map, mapToInt, and mapToObject

    Explanation :
    D. The map() method can fill in the blank. The lambda converts a String to an int, and Java uses autoboxing to turn that into an Integer. 
    The mapToInt() method can also fill in the blank, and Java doesn’t even need to autobox. There isn’t a mapToObject() in the stream API. 
    Note there is a similarly named mapToObj() method on IntStream. Since both map() and mapToInt() work here, option D is correct.

71. What does the following do? (Choose two.)

    public class Shoot {
        interface Target {
            boolean needToAim(double angle);
        }
        static void prepare(double angle, Target t) {
            boolean ready = t.needToAim(angle); // k1
            System.out.println(ready);
        }
        public static void main(String[] args) {
            prepare(45, d -> d > 5 || d < -5); // k2
        }
    }

    A. If any compiler errors are fixed, it prints true.
    B. If any compiler errors are fixed, it prints false.
    C. It compiles without issue.
    D. It doesn’t compile due to line k1.
    E. It doesn’t compile due to line k2.

    Explanation :
    A,C. This is a correct example of code that uses a lambda. The interface has a single abstract method. The lambda correctly takes one double parameter and returns a boolean. 
    This matches the interface. The lambda syntax is correct. Since it compiles, option C is correct. 
    Finally, option A is correct because 45 is greater than 5.

72. Which statements about the following code are correct?
    var data = List.of(1,2,3);
    int f = data.parallelStream()
    .reduce(1, (a,b) -> a+b, (a,b) -> a+b);
    System.out.println(f);

    A. It consistently prints 6.
    B. It consistently prints 7.
    C. It consistently prints another value.
    D. It does not consistently print the same value on every execution.
    E. It compiles but throws an exception at runtime.
    F. None of the above.

    Explanation :
    C. The reduction is parallel, but since the accumulator and combiner are well-behaved (stateless and associative), the result is consistent, making option D incorrect. 
    The identity is 1, which is applied to every element meaning the operation sums the values (1+1), (1+2), and (1+3). 
    For this reason, 9 is consistently printed at runtime, making option C correct.

73. What is the result of the following?

    11: var s1 = IntStream.empty();
    12: System.out.print(s1.average().getAsDouble());
    13: 
    14: var s2 = IntStream.of(-1,0, 1);
    15: System.out.print(s2.average().getAsDouble());

    A. Both statements print 0.
    B. Both statements print 0.0.
    C. The statements print different values.
    D. The code does not compile.
    E. The code compiles but throws an exception at runtime.

    Explanation :
    E. The average() method returns an OptionalDouble. This interface has a getAsDouble() method rather than a get() method, so the code does compile. 
    However, the stream is empty, so the optional is also empty. 
    When trying to get the value on line 12, the code throws a NoSuchElementException, making option E correct.

74. Which lambdas can replace the method references in this code? (Choose two.)

    Stream.of("fish", "mammal", "amphibian")
    .map(String::length)
    .findFirst()
    .ifPresent(System.out::println);

    A. x.length()
    B. x -> x.length()
    C. x -> x::length
    D. System.out.println(s)
    E. s -> System.out.println(s)
    F. s -> System.out::println

    Explanation :
    B,E. Options A and D are incorrect since they are missing the arrow (->), which makes them lambdas. 
    Options C and F are incorrect as they try to mix lambdas and method references. This leaves options B and E as the answers.

75. What collector can turn the stream at left to the Map at right?

    Sree                  | --> Sree  Kumar 
    Ken             true  |
    Kumar  ----->   false |
    Ye                    | --> Ken  Ye  Dan
    Dan
    
    A. Only grouping()
    B. Only groupingBy()
    C. Only partitioning()
    D. Only partitioningBy()
    E. Both grouping() and partitioning()
    F. Both groupingBy() and partitioningBy()

    Explanation :
    F. Both Collectors.groupingBy() and Collectors.partitioningBy() are useful for turning a stream into a Map. The other two methods do not exist. 
    The partitioningBy() method automatically groups using a Boolean key. However, we can also have a Boolean key with groupingBy(). 
    For example, we could write s -> s.length() > 3. Therefore, option F is correct.

