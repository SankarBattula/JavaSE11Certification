
1. The following figure represents a stream pipeline. Given this, would the boxes X, Y, Z best
    represent?
        X   --->    Y   --->    Z

    A. Origin, intermediate operation, and final operation
    B. Origin, intermediate operation, and sink
    C. Origin, intermediate operation, and terminal operation
    D. Source, intermediate operation, and final operation
    E. Source, intermediate operation, and sink
    F. Source, intermediate operation, and terminal operation

    Explanation :
    F. The source is the first operation, and the terminal operation comes last, making option F the answer. You need to know this terminology.

2. Which of the following is required for all valid lambda expressions?

    A. ()
    B. ->
    C. {}
    D. Parameter data type(s)
    E. None of the above

    Explanation :
    B. The lambda expression s -> true is valid, making options A, C, and D incorrect. 
    Parentheses, (), are not required on the left-hand side if there is only one variable. 
    Braces, {}, are not required if the right-hand side is a single expression. 
    Parameter data types are only required if the data type for at least one parameter is specified; otherwise, none are required. 
    The remaining choice, the arrow operator, ->, is required for all lambda expressions, 
    making option B the correct answer.

3. Fill in the blanks: The ______________ functional interface does not take any inputs, while
    the ______________ functional interface does not return any data.

    A. IntConsumer, LongSupplier
    B. IntSupplier, Function
    C. Supplier, DoubleConsumer
    D. UnaryOperator, Consumer
    E. None of the above

    Explanation :
    C. The Supplier functional interface does not take any inputs, while the Consumer functional interface does not return any data. 
    This behavior extends to the primitive versions of the functional interfaces, making option C the correct answer. 
    Option A is incorrect because IntConsumer takes a value, while LongSupplier returns a value. 
    Options B and D are incorrect because Function and UnaryOperator both take an input and produce a value.

4. What is the result of executing the following application multiple times?
    package bears;
    import java.util.*;
    public class Bounce {
        public static void main(String... legend) {
        List.of(1,2,3,4).stream()
            .forEach(System.out::println);
        List.of(1,2,3,4).parallel()
            .forEach(System.out::println);
        List.of(1,2,3,4).parallel()
            .forEachOrdered(System.out::println);
    } }

    A. Only the first stream prints the same order every time.
    B. Only the first and second streams print the same order every time.
    C. Only the first and third streams print the same order every time.
    D. All of the streams print the same order every time.
    E. None of the streams prints the same order every time.
    F. None of the above.

    Explanation :
    F. A List instance, which inherits the Collection interface, does not have a parallel() method. 
    Instead, parallelStream() must be used, making option F correct. 
    If the code was corrected to use parallelStream(), then the first and third streams would be consistently printed in the same order. 
    Remember that the forEachOrdered() method forces parallel streams to run in sequential order. 
    The order of the second operation would be unknown ahead of time, since it uses a parallel stream.

5. A lambda expression for which of the following functional interfaces could be used to return
    a Double value? (Choose two.)

    A. UnaryOperator
    B. BiPredicate
    C. BiOperator
    D. BiConsumer
    E. BiFunction
    F. BiSupplier

    Explanation :
    A,E. The UnaryOperator and BiFunction return a generic argument, such as Double, making options A and E correct. 
    Option B is incorrect because all predicate functions return boolean. 
    Option C is incorrect because BiOperator does not exist in the java.util.function package. The correct name is BinaryOperator. 
    Option D is incorrect because all consumer functions return void. 
    Finally, option F is incorrect because BiSupplier does not exist in the java.util.function package. 
    Supplier functions return values, and Java does not support methods with more than one return type.

6. What does the following output?

    var list = new ArrayList<String>();
    list.add("Austin");
    list.add("Boston");
    list.add("San Francisco");
    var c = list.stream()
        .filter(a -> a.length() > 10) // line x
        .count();
    System.out.println(c + " " + list.size());

    A. 1 1
    B. 1 3
    C. 2 3
    D. The code does not compile due to line x.
    E. None of the above.

    Explanation :
    B. The stream pipeline is correct and filters all values out that are 10 characters or smaller. 
    Only San Francisco is long enough, so c is 1. 
    The stream() call creates a new object, so stream operations do not affect the original list. 
    Since the original list is still 3 elements, 
    option B is correct.

7. Identify the correct functional interfaces to fill in this table correctly. (Choose three.)
    _________________________________________________________
    |   Functional Interface    |      Possible Return Type |
    _________________________________________________________
    |   Interface               |      X Boolean            |
    |   Interface               |      Y int                |
    |   Interface               |      Z Void               |
    ---------------------------------------------------------

    A. Interface X is Predicate.
    B. Interface X is Supplier.
    C. Interface Y is Comparator.
    D. Interface Y is Supplier.
    E. Interface Z is Consumer.
    F. Interface Z is Supplier.

    Explanation :
    B,C,E. Interface X is tricky. If it returned a boolean primitive, option A would be correct as Predicate returns a boolean. 
    However, it returns a wrapper object, so it has to be a Supplier, making option B the answer instead.
    Interface Y and Z are more straightforward as a Comparator and Consumer, respectively. 
    This makes options C and E the final two answers

8. What is a common reason for a stream pipeline not to run?

    A. The source doesn’t generate any items.
    B. There are no intermediate operations.
    C. The terminal operation is missing.
    D. The version of Java is too old.
    E. None of the above.

    Explanation :
    C. Option A is incorrect because a pipeline still runs if the source doesn’t generate any items and the rest of the pipeline is correct. 
    Granted, some of the operations have nothing to do, but control still passes to the terminal operation. 
    Option B is incorrect because intermediate operations are optional. 
    Option C is the answer. The terminal operation triggers the pipeline to run. 
    Option D is incorrect because the code would not compile at all if the version of Java were too old.

9. Which functional interface takes a long value as an input argument and has an
    accept() method?

    A. LongConsumer
    B. LongFunction
    C. LongPredicate
    D. LongSupplier
    E. None of the above

    Explanation :
    A. The LongSupplier interface does not take any input, making option D incorrect. It also uses the method name getAsLong(). 
    he rest of the functional interfaces all take a long value but vary on the name of the abstract method they use. 
    LongFunction contains apply() and LongPredicate contains test(), making options B and C, respectively, incorrect. 
    That leaves us with LongConsumer, which contains accept(), making option A the correct answer.

10. Given a parallel Stream<T>, which method would you use to obtain an equivalent serial
    Stream<T>?

    A. unordered()
    B. reduce()
    C. concat()
    D. stream()
    E. boxed()
    F. None of the above

    Explanation :
    F. The correct method to obtain an equivalent sequential stream of an existing stream is sequential(), which is inherited by any class that implements BaseStream<T>. 
    Since this isn’t an option, option F is correct. 
    Note that unordered() creates a stream that can be evaluated in any order, but it can still be processed in a sequential or parallel stream.

11. Which of the following is a valid lambda expression?

    A. r -> {return 1==2}
    B. (q) -> true
    C. (x,y) -> {int test; return test>0;}
    D. a,b -> true
    E. None of the above

    Explanation :
    B. Option A is incorrect because the lambda expression is missing a semicolon (;) at the end of the return statement. 
    Option C is incorrect because the local variable test is used without being initialized. Option D is also incorrect. 
    The parentheses are required on the left-hand side of the lambda expression when there is more than one value or a data type is specified. 
    Option B is the correct answer and the only valid lambda expression.

12. Which are true of the following? (Choose two.)
    var empty = Optional.empty();
    var param = Optional.of(null);
    var method = Optional.ofNullable(null);

    A. All of these will run without error.
    B. One of the lines fails to compile or throws an exception.
    C. Two of the lines fail to compile or throw an exception.
    D. None of these returns true when calling opt.isPresent()
    E. One of these returns true when calling opt.isPresent()
    F. Two of these return true when calling opt.isPresent()

    Explanation :
    B,D. The second line throws a NullPointerException when you pass a null reference to the of() method. The others compile and run successfully, making option B correct. 
    The first and third lines return false because they represent an empty Optional. This makes option D the other answer

13. Which of the following statements about DoubleSupplier and Supplier<Double>
    is not true?

    A. Both are functional interfaces.
    B. Both take zero parameters.
    C. Lambdas for both can return a double value.
    D. Lambdas for both cannot return a null value.
    E. One supports a generic type; the other does not.
    F. All of these are true.

    Explanation :
    D. Both are functional interfaces in the java.util.function package, making option A true. 
    Additionally, both lack parameters, making option B true. 
    The major difference between the two is that Supplier<Double> takes the generic type Double, while the other does not take any generic type and instead uses the primitive double. 
    For this reason, options C and E are true statements. For Supplier<Double> in option C, remember that the returned double value can be implicitly autoboxed to Double. Option D is the correct answer. 
    Lambdas for Supplier<Double> can return a null value since Double is an object type, while lambdas for DoubleSupplier cannot; they can only return primitive double values.

14. What is the output of the following program?
    import java.util.stream.*;
    public class Bull {
        void charge() {
            IntStream.range(1,6)
                .parallel()
                .forEachOrdered(System.out::print);
        }
        public static void main(String[] args) {
            var b = new Bull();
            b.charge();
        }
    }

    A. 12345
    B. 54321
    C. The output cannot be determined ahead of time.
    D. The code does not compile.
    E. An exception is thrown at runtime.
    F. None of the above.

    Explanation :
    A. Even though a parallel stream is used, the forEachOrdered() method forces the stream to operate in the order of its data source. 
    The code compiles and runs without issue rinting 12345 every time, and making option A correct. 
    If forEach() was used instead, then the output would vary at runtime.

15. Fill in the blank with the functional interface from java.util.function that allows the
    code to compile and print 3 at runtime.

    _____________ transformer = x -> x;
    var prime = List.of(3,1,4,1,5,9)
        .stream()
        .limit(1)
        .peek(s -> {})
        .mapToInt(transformer)
        .peek(s -> {})
        .sum();
    System.out.println(prime);

    A. Function<Integer,Integer>
    B. UnaryOperator<Integer>
    C. ToIntFunction<Integer>
    D. IntUnaryOperator
    E. The code does not compile regardless of what functional interface is placed in the blank.
    F. The code is capable of compiling, but since prime is an OptionalInt value, it cannot be 3 at runtime.

    Explanation :
    C. The first line that contains the lambda expression will actually compile with any of the functional interfaces listed in the options. 
    The stream operation, though, will compile only if ToIntFunction<Integer> is used. 
    It requires this functional interface, which takes a generic argument and returns int. For this reason, option C is correct. 
    Option F is incorrect because sum() on an IntStream returns an int, not an OptionalInt. 
    Note that the peek() operations in this stream have no effect.

16. Which fills in the blank so the code is guaranteed to print 1?
    var stream = Stream.of(1, 2, 3);
    System.out.println(stream.__________);

    A. anyMatch()
    B. findAny()
    C. first()
    D. min()
    E. None of the above

    Explanation :
    E. Option A is incorrect because anyMatch() returns a boolean. 
    Option B is incorrect because findAny() might not return 1. The result could be any of the three numbers. 
    Option C is incorrect because there is no first() method available as a terminal operation. 
    Option D is tempting because there is a min() method. However, since we are working with a Stream (not a primitive stream like IntStream), 
    this method requires a Comparator as a parameter. Therefore, option E is the answer.

17. What is the result of the following?

    6: var list = new ArrayList<String>();
    7: list.add("Monday");
    8: list.add(String::new);
    9: list.add("Tuesday");
    10: list.remove(0);
    11: System.out.println(list.get(0));

    A. null
    B. An empty String.
    C. Monday
    D. The code does not compile.
    E. The code compiles but throws an exception at runtime.

    Explanation :
    D. Line 8 does not compile. String::new is a constructor reference. 
    This constructor reference is equivalent to writing the lambda () -> new String(). It participates in deferred execution. 
    When it is executed later, it will return a String. 
    It does not return a String on line 8, though. The method reference is a Supplier<String>, which cannot be stored in list. 
    Since the code does not compile, option D is correct.

